{"0": {
    "doc": "Add a private constructor to hide the implicit public one",
    "title": "Add a private constructor to hide the implicit public one.",
    "content": "Utility classes should not have public constructors . 유틸리티 클래스는 public 생성자를 갖고 있으면 안된다. Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors. static 멤버만 갖고 있는 클래스를 유틸리티 클래스로 보고, (추상화된 클래스더라도) public 생성자를 갖고 있으면 안된다. Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined. 자바는 모든 클래스에 public 생성자를 갖고 있다. (선언하지 않아도) . 그러므로 적어도 public하지 않은 생성자를 한개는 정의해야함. [잘못된 코드] . class StringUtils { // Noncompliant public static String concatenate(String s1, String s2) { return s1 + s2; } } . [옳은 코드] . class StringUtils { // Compliant private StringUtils() { throw new IllegalStateException(\"Utility class\"); } public static String concatenate(String s1, String s2) { return s1 + s2; } } . [이 rule의 예외] . | 클래스에 main 메소드가 포함되어있으면 유틸리티 클래스라고 보지 않고, 이 규칙 적용에 제외됨. | . 문제가 되었던 코드에는 static 메소드 한개만 존재했음 . public class JsonParseUtil { public static getJson() { } } . —&gt; 수정. @NoArgsConstructor(access = AccessLevel.PRIVATE) // 파라미터없는 기본생성자를 생성 public class JsonParseUtil { public static getJson() { } } . ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S1118/#add-a-private-constructor-to-hide-the-implicit-public-one",
    "relUrl": "/docs/quality/sonarqube/S1118/#add-a-private-constructor-to-hide-the-implicit-public-one"
  },"1": {
    "doc": "Add a private constructor to hide the implicit public one",
    "title": "Add a private constructor to hide the implicit public one",
    "content": " ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S1118/",
    "relUrl": "/docs/quality/sonarqube/S1118/"
  },"2": {
    "doc": "Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used",
    "title": "Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used.",
    "content": "[원인] . java:s1149 룰에 대한 것으로 . 여기에 위반되는 이유는 static 메소드나 클래스에 StringBuilder가 아닌 StringBuffer등 멀티쓰레드에 적합한 API를 사용했기 떄문이다. [해결] . 나 같은 경우는 StringBuilder로 변경. [참고] . https://stackoverflow.com/questions/16672730/which-class-to-use-for-this-static-method-stringbuffer-or-stringbuilder . ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S1149/#synchronized-classes-vector-hashtable-stack-and-stringbuffer-should-not-be-used",
    "relUrl": "/docs/quality/sonarqube/S1149/#synchronized-classes-vector-hashtable-stack-and-stringbuffer-should-not-be-used"
  },"3": {
    "doc": "Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used",
    "title": "Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used",
    "content": " ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S1149/",
    "relUrl": "/docs/quality/sonarqube/S1149/"
  },"4": {
    "doc": "Convert the abstract class \"TemplateContentHandler\" into an interface",
    "title": "Convert the abstract class “TemplateContentHandler” into an interface.",
    "content": "Abstract classes without fields should be converted to interfaces. 필드가 없는 추상화 클래스는 인터페이스로 되어야한다. With Java 8’s “default method” feature, any abstract class without direct or inherited field should be converted into an interface. However, this change may not be appropriate in libraries or other applications where the class is intended to be used as an API. java8에서 제공하는 “default method” 기능으로, 어떤 추상화 클래스든 인터페이스로 바뀔수 있다. 그러나 이렇게 변경하는게 API로 제공된 어플리케이션이나 라이브러리인 경우는 맞지 않을 수 있다. (반드시 적용하는 룰은 아님) . Note that this rule is automatically disabled when the project’s sonar.java.source is lower than 8. ‘sonar.java.source’가 8보다 낮으면, 이 규칙은 자동적으로 disable상태 . [잘못된 코드] . public abstract class Car { public abstract void start(Environment c); public void stop(Environment c) { c.freeze(this); } } . [맞는 코드] . public interface Car { public void start(Environment c); public default void stop(Environment c) { c.freeze(this); } } . ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S1610/#convert-the-abstract-class-templatecontenthandler-into-an-interface",
    "relUrl": "/docs/quality/sonarqube/S1610/#convert-the-abstract-class-templatecontenthandler-into-an-interface"
  },"5": {
    "doc": "Convert the abstract class \"TemplateContentHandler\" into an interface",
    "title": "Convert the abstract class \"TemplateContentHandler\" into an interface",
    "content": " ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S1610/",
    "relUrl": "/docs/quality/sonarqube/S1610/"
  },"6": {
    "doc": "Source files should not have any duplicated blocks",
    "title": "Source files should not have any duplicated blocks",
    "content": " ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S2440/",
    "relUrl": "/docs/quality/sonarqube/S2440/"
  },"7": {
    "doc": "Source files should not have any duplicated blocks",
    "title": "1 duplicated blocks of code must be removed.",
    "content": "[원인] . block자체가 중복되는 코드들이 존재할 때 발생 . 의존성이 없는 컴포넌트였지만, 한개의 서비스안에 위치했기 때문에 발생 . [해결] . 중복되는 파일 중 한개를 열어서 왼쪽 회색 부분에 마우스 오버하면 duplicated된 block을 확인할 수 있다. 해결 방법은 여러가지가 되겠지만, 중복적인 코드가 필요한 이유 파악하고 제거 또는 대체를 하면 된다. ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S2440/#1-duplicated-blocks-of-code-must-be-removed",
    "relUrl": "/docs/quality/sonarqube/S2440/#1-duplicated-blocks-of-code-must-be-removed"
  },"8": {
    "doc": "Refactor this method to reduce its Cognitive Complexity from 20 to the 15 allowed",
    "title": "Refactor this method to reduce its Cognitive Complexity from 20 to the 15 allowed.",
    "content": "try { String conversationId = kakaoMessageFlowService.open(kakaoMessage.getKakaoUser().getSenderKey()); if (StringUtils.isNotEmpty(conversationId)) { activeKakaoFlowService.register(activeKakaoKey, kakaoMessage.toConversationDomain(conversationId)); } } catch (Exception e) { if (e instanceof DataIntegrityViolationException || e instanceof ResourceAlreadyExistsException) { for (int i = 0; i &lt; 3; i++) { log.warn(\"ActiveKakao DuplicateKeyException occurred. - retrying..\" + activeKakaoKey); Optional&lt;KakaoRdo&gt; kakaoRdo = findAllByUserStatus(kakaoMessage.getKakaoUser()); if (kakaoRdo.isPresent()) { break; } try { Thread.sleep(500L); } catch (Exception ex) { log.error(ExceptionUtils.getStackTrace(e)); } } } else { try { activeKakaoFlowService.remove(activeKakaoKey); } catch (Exception ex) { log.warn(e.getMessage()); } } } . 문제 : 인지 복잡도가 높아서 문제 (빨간색 block된 부분) - 총 20개의 복잡도 발생한 코드 . 해결: instanceof로 익셉션 구분한 부분을 catch로 올림 . } catch (DataIntegrityViolationException | ResourceAlreadyExistsException e) { } catch (Exception ex) { } . ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S3776/#refactor-this-method-to-reduce-its-cognitive-complexity-from-20-to-the-15-allowed",
    "relUrl": "/docs/quality/sonarqube/S3776/#refactor-this-method-to-reduce-its-cognitive-complexity-from-20-to-the-15-allowed"
  },"9": {
    "doc": "Refactor this method to reduce its Cognitive Complexity from 20 to the 15 allowed",
    "title": "Refactor this method to reduce its Cognitive Complexity from 20 to the 15 allowed",
    "content": " ",
    "url": "http://localhost:4000/docs/quality/sonarqube/S3776/",
    "relUrl": "/docs/quality/sonarqube/S3776/"
  },"10": {
    "doc": "Alarm Bot",
    "title": "게시물 업데이트 알람 봇 만들기",
    "content": ":: 요구사항 . | 카카오 비지니스API 공지사항 중 신규 게시물이 등록되면 슬랙DM으로 전송 | . :: 개발항목 . | 일배치 체크 | python slack 라이브러리 이용 | . ",
    "url": "http://localhost:4000/docs/sub-projects/alarm_bot/#%EA%B2%8C%EC%8B%9C%EB%AC%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%95%8C%EB%9E%8C-%EB%B4%87-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    "relUrl": "/docs/sub-projects/alarm_bot/#게시물-업데이트-알람-봇-만들기"
  },"11": {
    "doc": "Alarm Bot",
    "title": "Alarm Bot",
    "content": " ",
    "url": "http://localhost:4000/docs/sub-projects/alarm_bot/",
    "relUrl": "/docs/sub-projects/alarm_bot/"
  },"12": {
    "doc": "BrowserMatch",
    "title": "BrowserMatch",
    "content": "기본 아파치를 윈도우에 설치하고 나니 httpd-ssl.conf에 . 아래 설정이 있었다. BrowserMatch “.MSIE.” \\nokeepalive ssl-unclean-shutdown \\downgrade-1.0 force-response-1.0 . 콘솔에 로그인해서 상담하기까지 활성화하는데 1분이나 걸리게 되어서 . 주석을 하고 재시작하니, 엄청 빨라짐. 파악해본결과 이 블로그에서 (http://blogs.msdn.com/b/ieinternals/archive/2011/03/26/https-and-connection-close-is-your-apache-modssl-server-configuration-set-to-slow.aspx) . Four years ago, there was apublic callto update the guidance to reflect the fact that users of more modern browsers were paying an unneeded performance penalty. Finally, in June 2010, the default guidance was changed in recognition of the fact that the problem never affected IE6 and later: . BrowserMatch “.MSIE [1-5].” \\nokeepalive ssl-unclean-shutdown \\downgrade-1.0 force-response-1.0 . Unfortunately, many major Apache installations still haven’t been updated with even this guidance. Also, alert readers will spot a very obvious problem with the “new” regular expression. In the expression above, any IE version that starts with“1” will be treated as outdated and served connection slowly without Keep-Alive. Internet Explorer 1.0 didn’t even support SSL at all (SSL was added in 2.0), but worse, this loosely-written regular expression will also matchfutureMSIE 10.0,MSIE 11.0,MSIE 12.0(etc)**user-agent strings. Hence, Apache hosts will one day find that thenewestbrowsers are forced into the “slow” lane! . At the very least, Apache hosts should update their regular expression to this: . BrowserMatch “.MSIE [2-5]..” \\nokeepalive ssl-unclean-shutdown \\downgrade-1.0 force-response-1.0 . …but ultimately, they should probably remove this hack altogether. The ancient Internet Explorer 6’s marketshare is in decline, and there’s almost never any business reason to try to accommodate even older browsers. 요약하면 삭제해야할 설정인데 아파치에서 아직도 껴서 배포하고 있다는 것.. 원래 BrowserMatch로 사용할 수 있는 유요한 설정은 특정 버전의 브라우저에 문제가 있어서 아래처럼 분기하고자 할때 쓴다. (http://webdir.tistory.com/178) . BrowserMatch “Mozilla/2” nokeepalive . BrowserMatch “MSIE 4.0b2;” nokeepalive downgrade-1.0 force-response-1.0 . BrowserMatch “RealPlayer 4.0” force-response-1.0 . BrowserMatch “Java/1.0” force-response-1.0 . BrowserMatch “JDK/1.0” force-response-1.0 . BrowserMatch 지시자는 특정 브라우저들에 대한 특정 수행을 지시하기 위한 설정들이다. | 첫번째 것은 네스케이프 2.x 또는 그를 흉내내는 브라우저에 대하여 KeepAlive 기능을 쓰지 않도록 한다. 이 브라우저들은 KeepAlive 구현에 문제점을 갖고 있기 때문이다. | 두번째 것은 HTTP/1.1을 잘못 구현하였고 301 또는 302 (redirect)반응에 대하여 KeepAlive를 제대로 지원하지 못하는 마이크로소프트 인터넷 익스플로러 4.0b2를 위한 것이다. | 세번째 것은 네번째 다섯번째 것들은 기본적인 1.1 반응도 제대로 처리하지 못함으로써 HTTP/1.1 스펙을 위반하고 있는 브라우저에 대하여 HTTP/1.1 반응을 하여 하지 않도록 한다. | . BrowserMatch “Microsoft Data Access Internet Publishing Provider” redirect-carefully . BrowserMatch “MS FrontPage” redirect-carefully . BrowserMatch “^WebDrive” redirect-carefully . BrowserMatch “^WebDAVFS/1.[0123]” redirect-carefully . BrowserMatch “^gnome-vfs/1.0” redirect-carefully . BrowserMatch “^XML Spy” redirect-carefully . BrowserMatch “^Dreamweaver-WebDAV-SCM1” redirect-carefully . 위 지시자들도 구현에 문제가 있는 것들에 대한 처리방식을 지정한 것이다. ",
    "url": "http://localhost:4000/docs/errors/apache1/",
    "relUrl": "/docs/errors/apache1/"
  },"13": {
    "doc": "★bookmark",
    "title": "★bookmark",
    "content": "Keep looking. https://baek.dev/ . https://greensock.com/ . ",
    "url": "http://localhost:4000/docs/bookmark/",
    "relUrl": "/docs/bookmark/"
  },"14": {
    "doc": "Bridge pattern",
    "title": "Bridge pattern",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns/bridge_pattern/",
    "relUrl": "/docs/patterns/bridge_pattern/"
  },"15": {
    "doc": "Chain of Responsibility",
    "title": "Chain of Responsibility",
    "content": "역학 사슬 패턴 . | 체인에 묶인 객체들끼리 순서대로 책임을 넘기는 구조 | . ",
    "url": "http://localhost:4000/docs/patterns/chain_of_responsibility/",
    "relUrl": "/docs/patterns/chain_of_responsibility/"
  },"16": {
    "doc": "Chain of Responsibility",
    "title": "AS-IS.",
    "content": ". | 하나의 서비스에서 접수 처리와 메시지 전송 기능이 혼재 | . ",
    "url": "http://localhost:4000/docs/patterns/chain_of_responsibility/#as-is",
    "relUrl": "/docs/patterns/chain_of_responsibility/#as-is"
  },"17": {
    "doc": "Chain of Responsibility",
    "title": "TO-BE.",
    "content": ". | 접수 처리 프로세스와 메시지 전송 프로세스를 별개로 분리 | 프로세스 순서를 체인으로 강제 ( 접수 프로세스 진행 후 → 메시지 전송 프로세스 진행) | . :: Client . // 우선순위 btalkMessageProcessor -&gt; btalkReceptionProcessor public void message(ConversationMessage conversationMessage) { btalkMessageProcessor.setNext(btalkReceptionProcessor); btalkMessageProcessor.support(conversationMessage); } . :: Handler Processor . @Slf4j public abstract class BtalkProcessor { private BtalkProcessor next = null; public BtalkProcessor setNext(BtalkProcessor next) { this.next = next; return next; } public final void support(ConversationMessage conversationMessage) { if (process(conversationMessage)) { action(conversationMessage); } else if (next != null) { next.support(conversationMessage); } else { log.error(\"There is no next process of btalk.\"); } } public abstract boolean process(ConversationMessage conversationMessage); public abstract void action(ConversationMessage conversationMessage); } . :: Sub Processor . [btalkMessageProcessor] public class BtalkMessageProcessor extends BtalkProcessor { @Override public boolean process(ConversationMessage conversationMessage) { return isPresent(conversationMessage); } @Override public void action(ConversationMessage conversationMessage) { sendMessage(conversationMessage); } } [btalkReceptionProcessor] public class BtalkReceptionProcessor extends BtalkProcessor { @Override public boolean process(ConversationMessage conversationMessage) { return !isPresent(conversationMessage); } @Override public void action(ConversationMessage conversationMessage) { reception(conversationMessage); } } . 참고. https://lktprogrammer.tistory.com/45 . ",
    "url": "http://localhost:4000/docs/patterns/chain_of_responsibility/#to-be",
    "relUrl": "/docs/patterns/chain_of_responsibility/#to-be"
  },"18": {
    "doc": "Clipping",
    "title": "Clipping",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "http://localhost:4000/docs/clipping",
    "relUrl": "/docs/clipping"
  },"19": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "Data Analyst Nanodegree Program 후기",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/",
    "relUrl": "/docs/mooc/udacity/data_analyst/"
  },"20": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "강의 URL",
    "content": "2017년도에 수강했던 강의라 지금은 해당 강좌가 없어지고, 대체 강좌들이 생긴 것 같다. ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/#%EA%B0%95%EC%9D%98-url",
    "relUrl": "/docs/mooc/udacity/data_analyst/#강의-url"
  },"21": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "학습 툴",
    "content": ". | python | jupyter notebook | anaconda | 노트와 연필 ← 필수 | ztable.jpg ← 소중… | . ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/#%ED%95%99%EC%8A%B5-%ED%88%B4",
    "relUrl": "/docs/mooc/udacity/data_analyst/#학습-툴"
  },"22": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "강의 구성",
    "content": ". | udacity에서 전문대학처럼 전문가를 양성하고자 2017년도에 nanodegree강좌를 여러개 만들었었고, 이 수업은 그 중 하나로 한달에 30~40만원했던 수업;; | 강좌를 모두 학습하고 과제를 모두 통과하면 degree를 주고 채용연계까지 시켜주는 커리큘럼이 있었다. | . ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/#%EA%B0%95%EC%9D%98-%EA%B5%AC%EC%84%B1",
    "relUrl": "/docs/mooc/udacity/data_analyst/#강의-구성"
  },"23": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "선수 학습 조건",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/#%EC%84%A0%EC%88%98-%ED%95%99%EC%8A%B5-%EC%A1%B0%EA%B1%B4",
    "relUrl": "/docs/mooc/udacity/data_analyst/#선수-학습-조건"
  },"24": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "언어 지원",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/#%EC%96%B8%EC%96%B4-%EC%A7%80%EC%9B%90",
    "relUrl": "/docs/mooc/udacity/data_analyst/#언어-지원"
  },"25": {
    "doc": "Data Analyst Nanodegree Program 후기",
    "title": "학습 후기",
    "content": ". | 저는 총 3개월동안 평일엔 퇴근해서 강의듣고, 주말엔 과제하면서 공부했던 기억이 난다. | 과제를 제출하면, 첨삭을 잘 해줬던 것도 기억이 난다. 타이타닉 과제는 리뷰를 여러번 받아서, 아직도 기억이 생생~ | . ",
    "url": "http://localhost:4000/docs/mooc/udacity/data_analyst/#%ED%95%99%EC%8A%B5-%ED%9B%84%EA%B8%B0",
    "relUrl": "/docs/mooc/udacity/data_analyst/#학습-후기"
  },"26": {
    "doc": "Decorator pattern",
    "title": "Decorator pattern",
    "content": "데코레이터 패턴 . | 예를 들어서, Set인스턴스를 감싸는(wrap) 래퍼 클래스를 만들고, 이 클래스에 계측 기능을 덧씌우는 것을 말함 | . static void walk(Set&lt;Dog&gt; dogs) { InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs); } . ",
    "url": "http://localhost:4000/docs/patterns/decorator_pattern/",
    "relUrl": "/docs/patterns/decorator_pattern/"
  },"27": {
    "doc": "Effective Java",
    "title": "effective java 정리",
    "content": ". | 생성자 대신 정적 팩터리 메서드를 고려하라 . ex1) valueOf public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } ex2) instance or getInstance Object newArray = Array.newInstance(classObject, arrayLen); // instance 혹은 //getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다. ex3) getType FileStore fs = Files.getFileStore(path); // getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. \"Type\"은 팩터리 메서드가 반환할 객체의 타입이다. (1) 장점 . | 이름을 가질 수 있다. : 생성자만으로는 반환될 객체의 특성을 제대로 설명하지 못한다. 여러개의 생성자만으로는 어떤 역할을 하는지 구분하기 어렵다. | 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. : 생성 비용이 큰 객체가 자주 요청되는 상황이라면 성능을 높일 수 있다. 플라이웨이트 패턴도 비슷한 기법이라고 할 수 있다. | 인스턴스 통제가 가능하다. : 반복되는 요청에 같은 객체를 반환하는 식으로 언제 어느 인스턴스를 살아 있게 할지 철저히 통제할 수 있다. 즉, 싱글턴으로 만들수 있고 인스턴스화불가 상태로 만들 수도 있다. 예를 들어 인스턴스 통제를 통해 Enum타입을 인스턴스가 하나만 만들어짐을 보장한다. | 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. : API를 만들때 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어서 API를 작게 유지할 수 있다. | 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. :반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다. (예. EnumSet클래스에선 원소의 수에 따라 RegularEnumSet 또는 JumboEnumSet의 인스턴스를 반환) | 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. : service provider framework가 그런 경우인데, 클라이언트는 서비스 접근 api를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 조건이 없으면 기본 구현체를 반환하거나 다른 구현체를 반환한다. | . (2) 단점 . | 상속을 할 수 없다 : 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다. | 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. : 생성자처럼 API 문서에 명확히 드러나지 않으니 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야한다. | . 2. 생성자에 매개변수가 많다면 빌더를 고려하라 . [문제상황] . 매개변수가 많고 호출 경우가 다양해서 생성자로 설정을 하게 되면 보통 사용자가 설정하기 원치 않는 매개변수까지 설정해야하는 경우가 생기는데, 필드가 더 많아지게 되면 값의 의미가 무엇인지 헷갈릴 것이고 매개변수가 몇 개인지도 주의해서 세어보아야 할 것이다. ** 자바빈즈 패턴 : 선택 매개변수가 많을 때 활용할 수 있는데, 매개변수가 없는 생성자로 객체를 만든 후, setter메서드들을 호출해서 원하는 매개변수의 값을 설정하는 방식. 근데 이 자바빈즈 패턴은 일관성이 깨지고, 불변으로 만들수 없다. 디버깅도 어렵고 스레드 안전성도 보장하기 어려움 . [빌더패턴 활용] . | 필수 매개변수만으로 생성자 혹은 정적 팩터리를 호출해서 빌더 객체를 얻는다. | . public class NutritionFacts { private final int servingSize; private final int servings; public static class Builder { private final int servingSize; private final int servings; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } } private NutritionFacts(Builder builder) { serviceSize = builder.servingSize; servings = builder.servings; } } . [caller] NutritionFacts cocaCola = new NutritionFacts.Builder(240 ,8) .calories(100).sodium(35).carbohydrate(27).build(); . | 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다. (피자 예시) . | 각 계층의 클래스에 관련 빌더를 멤버로 정의하고 | 추상 클래스는 추상 빌더를 | 구현 클래스는 구현 빌더를 둔다. | . | 단점 . | 빌더 생성비용에 따라서 성능에 문제가 될 수 있다. | 매개변수가 4개 이상일 때, 점층적 생성자 패턴보다 활용 | . | . | private 생성자나 열거 타입으로 싱글턴임을 보증하라 | . | 생성자를 만들지 않으면 자동으로 기본생성자가 만들어지기때문에 인스턴스화가 되버린다. 이때 private생성자를 추가해서 인스턴스화를 막는다. —&gt; 이 방식으로 상속도 막게 된다. (상위 클래스의 생성자에 접근못하므로) | . | 인스턴스화를 막으려거든 private 생성자를 사용하라 . | 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 . | . | 많은 클래스가 의존하는 자원일 경우, 많이들 정적 클래스로 선언해서 사용하는데, 사용하는 자원에 따라 동작이 달라진다면 정적 유틸리티 클래스나 싱글턴 방식은 맞지 않다. | 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 해본다. | . public class SpellChecker { private final Lexiton dictionary; public SpellCheck(Lexiton dictionary) { this.dictionary = Objects.requireNonNull(dictionary); } } . | 불필요한 객체 생성을 피하라 . | . | 생성자 대신 정적 팩터리 메서드를 만들면 불필요한 객체 생성을 피할 수 있다. | . (ex. Boolean.valueOf(String) ) . | 하지만 문자열을 검사하는 메소드의 경우는 비용이 드므로, 캐싱해서 재사용하도록 한다. | . (ex. Pattern은 정규표현식에 해당하는 finite state machine을 만들기 때문에 인스턴스 생성 비용이 높다. —&gt; 이 경우는 Pattern 인스턴스를 클래스 초기화할 때 캐싱해두고 인스턴스를 재사용하면 된다.) . | 오토박싱의 경우도 비용이 든다. 박싱된 기본 타입보다 기본타입을 사용하고 오토박싱이 되지 않도록 한다. | . | finalizer와 cleaner사용을 피하라 | . | 언제 실행될지 예측할 수 없고, 실행될 때까지 열어둔다면 열수 있는 파일 개수에 영향이 가게된다. | 수행여부조차 보장하지 않는다. | 가비지 컬렉터의 효율을 떨어뜨린다 | . | equals | . | 동치성 검사는 언제 하는가, 즉 재정의가 필요할 때는? . | 상위 클래스의 equals가 재정의되지 않았을 때, 주로 값 관련 클래스들이 그렇다 | . | equals를 재정의했으면 반드시 hashcode도 재정의해야한다. | . | toString을 재정의해야하는 이유 . | Object의 기본 toString으로는 정보를 알수 없으므로, 사람이 알아볼수 있는 포맷을 갖춰서 반환하도록 해야한다. | 쓸모없는 메시지로 표시되는 것보단, 알아볼수 있다면 디버깅에도 도움 | toString이 필요없는 경우 | . | 정적 유틸리티 클래스 | 열거타입 클래스 - 자바가 이미 제공하는 것으로 추운 | . | 상속보다는 컴포지션을 사용하라 . | 상속 후 재정의로 인해 발생할 수 있는 오류를 방지해야한다. | 컴포지션 설계 - 재정의가 필요하면, 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private필드로 기존 클래스의 인스턴스를 참조하게끔 한다. | 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야한다. | . | 인터페이스는 구현하는 쪽을 생각해 설계하라 | . | 디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. | 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다. | . | . | 태그 달린 클래스보다는 클래스 계층구조를 활용하라 . | 태그 달린 클래스란? | . | 클래스 중에 두가지 이상의 의미를 표현할 수 있으며, 그 중 표현하는 의미를 태그 값으로 알려주는 클래스 | 열거 타입 선언, 태그 필드, switch문 등 코드가 섞여있는 클래스 | 여러 구현이 혼합돼 있어서 가독성이 나쁘다. | 그 클래스에 새로운 의미를 추가할 때마다 모든 switch문에 코드를 추가해야하고 | 인스턴스의 타입만으로는 나타내는 의미를 알 수 없다. | . | . // ex) 태그달린 클래스 class Figure { enum Shape { RECTANGLE, CIRCLE }; final Shape shape; double radius; Figure(double radius) { shape = Shape.CIRCLE: this.radius = radius; } double area() { switch(shape) { case RECTANGLE; return length * width; default: throw new AssertionError(shape); } } } . | 태그달린 클래스 → 클래스 계층 구조로 변경한다. | 계층구조의 root가 되는 추상 클래스를 정의 | 태그값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다. | 태그에 상관없이 동작이 동일한 메서드들을 일반 메서드로 선언한다. | . abstract class Figure { abstract double area(); } class Circle extends Figure { final double radius; Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * (radius * radius); } } class Rectangle extends Figure { final double length; final double width; @Override double area() { return length * width; } } . | . | raw 타입은 사용하지 마라 . | 로 타입을 쓰게되면 타입 안정성을 잃게 된다. | 비한정적 와일드 카드 타입을 사용하라 - 로타입 컬렉션은 아무 원소나 넣을 수 있으니 타입불변식을 훼손할 수 있는데, Collection&lt;?&gt;은 null외에는 어떤 원소도 넣을 수 없다. | 예외) class리터럴에는 raw타입을 써야한다. - 예를 들어, List.class, String[].class. int.class는 허용하고 List.class 와 List&lt;?&gt;.class는 허용하지 않는다. | . | 배열보다는 리스트를 사용하라 . | 배열은 공변이다. 상위 타입과 하위 타입이 같이 변한다는 것. 반면 제네릭은 불공변이다. | . | 한정적 와일드카드를 사용해 API유연성을 높이라 . | 펙스(PECS) 공식: producer-extends, consumer-super | . | 매개변수화 타입 T가 생산자(producer)라면 &lt;? extends T&gt;를 사용하고 | 소비자(consumer)라면 &lt;? super T&gt;를 사용하라 | . | 제네릭과 가변인수를 함께 쓸 때는 신중하라 . | 제네릭과 varargs를 혼용하면 타입 안전성이 깨진다. | . | . static void dangerous(List&lt;String&gt;... stringLists) { List&lt;Integer&gt; intList = List.of(42); Object[] object = stringLists; objects[0] = intList; String s = stringLists[0].get(0); // ClassCastException발생 } . | 제네릭 varargs배열 매개변수에 값을 저장하는 것은 안전하지 않다. | . | 타입 안전 이종 컨테이너를 고려하라 . | int 상수 대신 열거 타입을 사용하라 . | 열거 타입이 근본적으로 불변이지만, 모든 필드는 final이어야 한다. | 필드를 public으로 선언해도 되지만, private으로 두고 별도의 public접근자 메소드를 두는게 낫다 | . | . public enum Planet { EARTH(3.302e+23, 2.439e6); private final double mass; Planet(double mass) { this.mass = mass; } public double mass() { return mass; } } . | 열거타입 클래스에 상수별로 다르게 동작해야 하는 경우, switch문 대신 상수별 메서드 구현을 사용하자 | 열거타입 상수 일부가 같은 동작을 공유한다면 전락 열거 타입 패턴을 사용하자. | . | 비트 필드 대신 EnumSet을 사용하라. | ordinal 인덱싱 대신 EnumMap을 사용하라. | . Map&lt;Plant.LifeCycle, Set&lt;Planet&gt;&gt; plantsByLifeCycle = new EnumMap&lt;&gt;(Plant.LifeCycle.class); for (Plant.LifeCycle lc : Plant.LifeCycle.values()) { plantsByLifeCycle.put(lc, new HashSet&lt;&gt;()); } for (Plant p :garden) { plantsByLifeCycle.get(p.lifeCycle).add(p); } . | EnumMap은 내부에서 배열을 사용하기 떄문에, ordinal 성능과 비등하다. | 아니면 스트림을 사용하면, 코드를 더 간략하게 할 수 있다 | . Arrays.stream(garden).collect(groupingBy(p -&gt; p.lifeCycle)); Arrays.stream(garden).collect(groupingBy(p -&gt; p.lifeCycle, () -&gt; new EnumMap&lt;&gt;(LifeCycle.class), toSet())); . | 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라. | 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다. (예: java.nio.file.LinkOption열거타입은 CopyOption, OpenOption인터페이스를 구현했다) | . | . // Operation.class public interface Operation { double apply(double x, double y); } // BasicOperation.class public enum BasicOperation implements Operation { PLUS(\"+\") { public double apply(double x, double y) {return x + y;} }; private final String symbol; BasicOperation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; } } // 확장가능 열거 타입 ExtendedOperation.class public enum ExtendedOperation implements Operation { EXP(\"^\") { public double apply(double x, double y) { return Math.pow(x, y); } }; private final String symbol; ExtendedOperation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; } } . | 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라 . | 아무 메서드도 담고 있지 않고, 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스라고 한다. (예: Serializable) | 마커 인터페이스가 마커 애너테이션 보다 나은 점 | . | 마커 인터페이스는 이를 구현한 클래스의 인스턴스를 구분하는 타입으로 쓸 수 있다. | 적용 대상을 더 정밀하게 지정할 수 있다. | 애너테이션으로 하면 Element.Type에 한정되는 반면, 인터페이스는 확장하면 그 하위 타입으로 보장된다. | . | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#effective-java-%EC%A0%95%EB%A6%AC",
    "relUrl": "/docs/clipping/java/effective_java/#effective-java-정리"
  },"28": {
    "doc": "Effective Java",
    "title": ":: 람다와 스트림",
    "content": ". | 익명 클래스보다는 람다를 사용하라 | . [as-is] Collections.sort(words, new Comparator&lt;String&gt;() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); [to-be] Collectoins.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length())); --&gt; Collection.sort(words, comparingInt(String::length)); --&gt; words.sort(comparingInt(String::length)); . | 전략패턴처럼, 함수 객체를 사용하는 과거 객체 지향 디자인 패턴에는 익명 클래스명 충분했다. | 자바8에서는 추상 메서드 하나짜리 인터페이스를 람다식으로 만들어 간략하게 사용할 수 있다. | 타입을 명시헤야 하는 경우를 제외하고는 람다의 모든 매개변수 타입은 생략하자 | . | 람다는 이름이 없고 문서화도 못한다. | 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야한다. (최대 3줄 안에 끝내는 것이 좋다) | . | 람다 함수 객체가 자신을 참조해야할 때는 this 키워드가 바깥 인스턴스를 가리키기 때문에 쓸수 없다. 이 경우는 익명 클래스를 써야한다. | 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있다. 따라서 람다를 직렬화하는 일은 극히 삼가야한다(익명 클래스의 인스턴스도 마찬가지). Comparator처럼 직렬화를 해야만한다면 private정적 중첩 클래스의 인스턴스를 사용하자 | . | 람다보다는 메서드 참조를 사용하라 . | 매개변수가 늘어날수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다. | . | . [as-is] map.merge(key, 1, (count, incr) -&gt; count + incr); [to-be] map.merge(key, 1, Ingeger::sum); . | 람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다. | 때로는 메서드 참조보다 람다가 더 간결할 때가 있다. | 제네릭 함수 타입의 경우 람다로는 불가능하나 메서드 참조로 가능하다. | . interface G1 { &lt;E extends Exception&gt; Object m() throws E; } interface G2 { &lt;F extends Exception&gt; String m() throws Exception; } interface G extends G1, G2 {} &lt;F extends Exception&gt; () -&gt; String throws F . | 표준 함수형 인터페이스를 사용하라 . | 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자 - 계산이 많을 때 성능이 느려진다. | . | 스트림은 주의해서 사용하라 . | 스트림 파이프라인은 지연 평가된다. 평가는 종단 연산이 호출될 때 이뤄지며 무한 스트림을 다룰 수 있게 해주는 열쇠이다. | 람다에서는 타입 이름을 자주 생략하므로 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다. | char용 스트림을 지원하지 않기 때문에, char값을 처리할 때는 스트림을 삼가는 편이 낫다. | . | 스트림에서는 부작용 없는 함수를 사용하라 . | 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다. | . | . // 잘못된 스트림 사용 Map&lt;String, Long&gt; freq = new HashMap&lt;&gt;(); try (Stream&lt;String&gt; words = new Scanner(file).tokens()) { words.forEach(word -&gt; { // forEach는 그저 스트림이 수행한 연산 결과를 보여주는 일만 해야한다. freq.merge(word.toLowerCase(), 1L, Long::sum); // freq라는 외부 상태를 수정하는 람다를 실행하는 문제 }); } // 올바른 스트림 사용 Map&lt;String, Long&gt; freq = try (Stream&lt;String&gt; words = new Scanner(file).tokens()) { freq = words.collect(groupingBy(String::toLowerCase, counting())); } . | forEach연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는데 쓰지 말자. | 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 toMap을 사용할 수 있다 | . // 문자열을 열거타입 상수에 맵핑한다. private static final Map&lt;String, Operation&gt; stringtoEnum = Stream.of(values()).collect( toMap(Object::toString, e -&gt; e)); . // 각 키와 해당 키의 특정 원소를 연관 짓는 맵을 생성하는 수집기 Map&lt;ARtist, Album&gt; topHits = albums.collect( toMap(Album::artist, a -&gt; a, maxBy(comparing(Album::sales)))); . // 마지막에 쓴 값을 취하는 수집기 toMap(keyMapper, valueMapper, (oldVal, newVal) -&gt; newVal) . | 반환 타입으로는 스트림보다 컬렉션이 낫다 . | for-each로 스트림을 반복할 수 없는 이유는 Stream이 Iterable을 extand하지 않아서이다. | 원소 시퀀스를 반환하는 공개API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는게 일반적으로 최선이다 | . | Collection인터페이스는 Iterable의 하위 타입이고 stream메서드도 제공하니 반복과 스트림을 동시에 지원한다. | Array도 Array.asList와 Stream.of메서드로 반복과 스트림을 지원할 수 있다. | . | . public static &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; of(List&lt;E&gt; list) { return IntStream.range(0, list.size()) .mapToObj(start -&gt; IntStream.rangeClosed(Start + 1, list.size()) .mapToObj(end -&gt; list.subList(start, end))) .flatMap(x -&gt; x); } . | 스트림 병렬화는 주의해서 적용하라 . | 환경이 아무디 좋아도 데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다. | 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다 | . | 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기 좋다는 특징이 있다 | 원소들을 순차적으로 실행할 때의 참조 지역성이 뛰어나다. 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요한 요소로 작용한다. | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#-%EB%9E%8C%EB%8B%A4%EC%99%80-%EC%8A%A4%ED%8A%B8%EB%A6%BC",
    "relUrl": "/docs/clipping/java/effective_java/#-람다와-스트림"
  },"29": {
    "doc": "Effective Java",
    "title": ":: 메소드",
    "content": ". | 매개변수가 유효한지 검사하라. | requireNonNull : null검사를 수동으로 하지 않아도 된다. 원하는 예외 메시지를 지정할 수 있다. 입력값을 그대로 반환도 된다. | . | . this.strategy = Objects.requireNonNull(strage, \"전략\"); . | 자바9에서는 Object의 범위 검사 기능을 추가했다. : checkFromIndexSize, checkFromToIndex, checkIndex | . | 적시에 방어적 복사본을 만들라 . | 외부 공격으로부터 인스턴스의 내부를 보호하려면 생서자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다. | . | . public Period(Date start, Date end) { this.start = new Date(start.getTime()); // 생성자를 수정해서 매개변수의 방어적 복사본을 만든다. this.end = new Date(end.getTime()); if (this.start.compareTo(this.end) &gt; 0) { throw new IllegalArgumentException(); } } . | 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다. 단 성생저와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다. | 방어적 복사에는 성능 저하가 따르고 또 항상 쓸 수 있는 것도 아니다. 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음이 신뢰된다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임을 클라이언트에 있음을 문서에 명시하도록 하자 | . | 메서드 시그니처를 신중히 설계하라 . | 메서드 이름을 신중히 짓자. 표준 명명 규칙을 따른다 | 편의 메서드를 너무 많이 만들지 말자 | 매개변수 목록은 4개 이하가 좋다 | . | 매개변수를 짧게 줄여주는 기술 . | 여러 메서드로 쪼갠다. List인터페이스가 그렇다 | 잘못하면 메서드가 너무 많아질 수 있지만, 직교성을 높혀서 메서드 수를 줄여줄 수도 있다(직교성이 높다는 것은 공통점이 없는 기능들이 잘 분리되어있다는 뜻) | . | 매개변수 여러개를 묶어주는 도우미 클래스를 만드는 것으로 정적 멤버 클래스를 말한다. | 앞의 두개를 혼합한 것 - 매개변수 타입으로는 클래스보다는 인터페이스가 낫다. | 인터페이스가 있다면 직접 사용하자. 예를들어 HashMap을 넘기지 말고 Map을 사용하자. 그러면 TreeMap, ConcurrentHashMap, TreeMap등도 인수로 건낼 수 있다. - boolean보다는 원소 2개짜리 열거 타입이 낫다. | 메서드 이름상 boolean을 받아야 의미가 더 명확할 때는 예외다) | . | . 52.다중정의는 신중히 사용하라 . | 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다. | 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자. | 가변인수를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다. | . | 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다. | -XLint:overloads를 지정하면 이런 종류의 다중정의를 경고해준다. | . | 인수를 포워드하여 두 메서드가 동일한 일을 하도록 보장할 필요가 있다. | String클래스의 contentEquals메서드는 CharBuffer, String, StringBuilder, StringBuffer 등등 비슷한 부류의 타입을 가지고 있고 이들의 공통 인터페이스로 CharSequence가 등장했다. | . public boolean contentEquals(StringBuffer sb) { return contentEquals((CharSequence) sb); } . | String클래스의 valueOf(char[])과 valueOf(Object)는 같은 객체를 건네더라도 전혀 다른 일을 수행한다. | . | . | 가변인수는 신중히 사용하라 . | 가변인수는 인수 개수가 정해지지 않았을 때 유용하다. | 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화하는 비용이 발생한다. | . | 인수 3개까지는 다중정의 메서드를 만들고 4개부터 가변 인수로 처리하는 방법으로 성능을 개선해볼 수 있다. | . | null이 아닌 빈 컬렉션이나 배열을 반환하라 . | null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어나기 때문에 빈 컬렉션이나 빈 배열로 반환하도록 한다. | Collections.emptyList, Collections.emptySet, Collections.emptyMap : 빈 컬렉션 할당이 성능을 떨어뜨릴 수 있기 때문에, 불변 컬렉션으로 반환하도록 한다 | 배열도 null을 반환하지 말고 길이가 0인 배열을 반환하라 | . | 그렇다고 미리 할당하지 말자. 성능이 나빠진다. | . | 옵셔널 반환은 신중히 하라 . | 옵셔널을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 경우보다 오류 가능성이 작다. | 옵셔널을 반환하는 메서드에서는 절대 null을 반환하지 말자 | . | Optional.of(value)에 null을 넣으면 npe가 발생하니 Optional.ofNullable(value)를 사용하면 된다. - 옵셔널은 검사 예외와 취지가 비슷하다. 즉 반환값이 없을 수도 있음을 API사용자에게 명확히 알려준다. - 옵셔널 활용 | 기본값을 정해둘 수 있다 | . String lastWordInLexicon = max(words).orElse(\"단어 없음...\"); . | 원하는 예외를 던질 수 있다 | . Toy myToy = max(toys).orElseThrow(TemperTantrumException::new); . | 항상 값이 채워져 있다고 가정한다. | . Element lastNobleGas = max(Elements.NOBLE_GASES).get(); . | . | 적합한 메서드를 찾지 못했다면 isPresent를 활용하자. | 자바9에서는 Optional에 stream()메서드가 추가되었다. | 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안된다. | Optional&lt;List&gt;를 반환하기보다는 빈 List를 반환하는게 좋다. | . | 박싱된 기본 타입을 담는 옵셔널은 기본타입보다 무겁다. OptionalInt, OptionalLong, OptionalDouble이 있다. 박싱된 기본타입을 담은 옵셔널을 반환하는 일은 없도록 하자. 단 Boolean, Byte, Character, Short, Float은 예외일 수 있다. | 옵셔널을 맵의 값으로 사용하면 안된다. | . | 공개된 API요소에는 항상 문서화 주석을 작성하라 . | 문서화 주석 작성법(How to Write Doc Comments)가 업계 표준 API | 메서드가 어떻게 동작하는지가 아닌, 무엇을 하는지를 기술해야한다. (how가 아닌 what을 기술해야 한다) | 포함해야하는 내용 | . | 메서드를 호출하기 위한 전제조건 | 메서드가 성공적으로 수행된 후에 만족해야하는 사후조건 | 부작용에 대한 내용 - 규칙 | ‘@param, ‘@return, ‘@throws태그의 설명에는 마침표를 붙이지 않는다. | 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다. | 열거타입을 문서화할 때는 상수들에도 주석을 달아야 한다. | 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다. | 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API설명에 포함해야 한다. | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#-%EB%A9%94%EC%86%8C%EB%93%9C",
    "relUrl": "/docs/clipping/java/effective_java/#-메소드"
  },"30": {
    "doc": "Effective Java",
    "title": ":: 일반적인 프로그래밍 원칙",
    "content": ". | 지연변수의 범위를 최소화하라 . | 메서드를 작게 유지하고 한 가지 기능에 집중한다 | . | . for (int i = 0, n = expensiveComputation(); i &lt; n; i++) { // 반복 변수 i,n에서, 반복여부를 결정짓는 i의 한계값을 n에 저장해서 반복 때마다 다시 계산해야하는 비용을 없앤다. } . | 라이브러리를 익히고 사용하라 . | Random을 사용하지 말고 ThreadLocalRandom으로 대체한다.(성능 좋음) | 포트 조인 풀이나 병렬 스트림에서는 SplittableRandom을 사용한다. | . | 박싱된 기본 타입보다는 기본 타입을 사용하라. | 기본 타입은 값만 가지고 있지만, 박싱된 기본타입은 값 + 식별성(identity)를 갖고 있다. | . | new Integer(42), new Integer(42) 로 연산하면, 두개가 다른 값으로 식별된다. 즉 같은 객체를 비교하는 것이 아니면 박싱된 기본 타입에 == 연산자를 사용할 시 오류가 빌생한다. - 박싱된 기본타입은 null을 가질 수 있다 - 기본타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다. | 박싱과 언박싱을 반복해서 일어나게 연산되는 경우를 만들면 안된다. - 기본타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본타입의 박싱이 자동으로 풀린다. - 박싱된 기본 타입을 사용하는 경우 | 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본타입을 담을 수 없으므로… . | 예) ThreadLocal는 안되고 ThreadLocal를 써야한다. | . | 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용한다. | . | 다른 타입이 적절하다면 문자열 사용을 피하라 . | 문자열은 다른 타입, 열거타입, 혼합타입을 대신하기에 적합하지 않다. | . | 오류가능성도 꺼지고, 파싱해야해서 느리고 | string에서 제공하는 기능에만 의존해야한다. - 권한을 표현하기에 적합하지 않다. | 예를 들어 쓰레드 지역변수를 선언할 때, 클라이언트에서 호출된 문자열로 쓰레드별 지역변수를 식별하게 되면, . | 각 클라이언트별로 고유한 키가 있어야하고 (공유되면 안되니까) | 결국 보안도 취약해진다. | . | 그래서 문자열 대신 Object클래스로 선언해본다. | . public final class ThreadLocal&lt;T&gt; { public ThreadLocal(); public void set(T value); public T get(); } . | 문자열 연결은 느리니 주의하라 . | 문자열 n개를 잇는 시간은 n제곱승에 비례한다. 문자열은 불변이라서 두 문자열을 연결한다치면 양쪽의 내용을 모두 복사해야 하므로 성능 저하가 발생한다. | String대신 StringBuilder를 사용하자 | . | 객체는 인터페이스를 사용해 참조하라 . | 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라 | . | 객체체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 뿐이다. | . | . Set&lt;Son&gt; sonSet = new LinkedHashSet&lt;&gt;(); . | 예외. | String이나 Integer같은 값 클래스의 경우 인터페이스로 설계할일이 거의 없으므로 클래스로 참조해야한다. | 클래스 기반으로 작성된 프레임워크의 객체들의 경우 인터페이스가 없다. OutputStream등 java.io패키지의 클래스들이 여기에 해당 | PriorityQueue클래스는 Queue인터페이스에는 없는 comparator메서드를 제공하는데 이 메소드를 꼭 사용해야하는 경우는 예외로 사용가능하다. | . | . | 리플렉션보다는 인터페이스를 사용하라 . | 리플렉션 단점 | . | 컴파일타임 타입검사가 주는 이점을 하나도 누릴 수 없다. | 리플렉션을 이용하면 코드가 지저분하고 장황해진다. | 성능이 떨어진다. | . | 네이티브 메서드는 신중히 사용하라 . | 네이티브 언어는 자바보다 플랫폼을 많이 타서 이식성도 낮고 디버깅도 어려우며 성능에도 안좋다. | . | 최적화는 신중히 하라 . | 최적화 규칙 | . | 하지마라 | 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지마라 | 각각의 최적화 시도 전후로 성능을 측정하라 - 성능을 제한하는 설계를 피하라 | 완성 후 변경하기 어려운 컴포넌트끼리 또는 외부 시스템과의 통신하는 경우(API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등) - 프로파일링 도구를 활용한다 | jmh | . | 일반적으로 통용되는 명명 규칙을 따르라 . | 자바언어명세 jls, 6.1 | 패키지명 | . | 8자 이하의 짧은 단어로 한다. | utilities보다는 util | . | 여러 단어로 구성된 이름이면 약어로 해도 된다. - 타입 매개변수 | 보통 한 문자로 표현한다 . | T : 임의의 타입 | E : 컬렉션 원소 타입 | K, V : 맵의 키와 값 | X : 예외 | R : 메서드 반환 타입 | T, U, V : 그 외에 임의 타입 시퀀스 . | 문법 규칙 | . | . | 패키지 : 따로 규칙 없다. | 클래스 . | 객체를 생성할 수 있는 클래스(열거타입 포함) 의 이름은 보통 단수 명사나 명사구를 사용 . ex) Thread, PriorityQueue, ChessPiece 등 . | 객체를 생성할 수 없는 클래스의 이름은 . | 복수형 명사 : Collectors, Collections 등 | 인터페이스 이름은 . | 클래스와 똑같이 짓는다 : Collection, Comparator | 형용사로 짓는다 : -able, -ible . ex) Runnable, Iterable, Accessible 등 . | . | . | . | 메서드 . | 동사나 목적어를 포함한 동사구로 짓는다 | boolean을 반환하는 메서드면 . | is, has + 명사/명사구/형용사로 기능하는 단어나 구로 구성한다 . ex) isDigit, isEmpty, isEnabled, hasSiblings . | . | 해당 인스턴스의 속성을 반환하는 메서드 . | 명사, 명사구, get으로 시작하는 동사구로 짓는다. | . | 객체의 타입을 바꿔서 반환하는 메서드 . | to + Type형태로 한다. ex) toString, toArray등 . | . | 객체의 내용을 다른 뷰로 보여주는 메서드 . | as + Type 형태로 한다. ex) asList . | . | 객체의 값을 기본 타입 값으로 반환하는 메서드 . | type + Value형태로 한다 . ex) intValue . | . | 정적 팩터리의 경우 . ex) valueOf, instance, getInstance, newInstance, getType, newType . | . | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9B%90%EC%B9%99",
    "relUrl": "/docs/clipping/java/effective_java/#-일반적인-프로그래밍-원칙"
  },"31": {
    "doc": "Effective Java",
    "title": ":: 예외",
    "content": ". | 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라 . | 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. API명세에 맞는 제약을 지키지 못했다는 뜻이다. 이 경우 복구할 수 있는 상황인지를 구분할 수 없다. 복구가 가능하다면 검사 예외를 그 외에는 런타임 예외를 사용하자 | . | 필요없는 검사 예외 사용은 피하라 . | API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우 외에는 비검사 예외를 사용하는 것이 좋다. | . | 표준 예외를 사용하라 . | 표준 예외를 재사용하라 - 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스 적재하는 시간도 적게 걸린다. | 대표되는 재사용 표준 예외 | . | IllegalStateException . | 인수값이 무엇이었든 어차피 실패했을 것라면 IllegaStateException | 그렇지 않으면 IllegalArgumentException | . | ConcurrentModificatonException : 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려고 할 때 | UnsupportedOperationException - 예외 | Exception, RuntimeException, THrowable, Error는 직접 재사용하지 말자. 이 예외들은 추상 클래스라고 생각하자 | . | 메서드가 던지는 모든 예외를 문서화하라 . | 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 ‘@throws태그를 사용하여 정확히 문서화 하자 | . | 메서드가 Exception이나 Throwable을 던진다고 선언해서는 안된다. 메서드는 사용자에게 각 예외를 대처할 수 있는 힌트를 줘야한다. 같은 맥락에서 발생할 여지가 있는 다른 예외들까지 삼켜버릴 수 있어 API 사용성을 크게 떨어뜨린다. - 메서드가 던질 수 있는 예외를 각각 ‘@throws태그로 문서화하되, 비검사 예외는 메서드 선언의 throws목록에 넣지말자. 그 이유는 검사냐 비검사냐에 따라 API 사용자가 해야 할 일이 달라지므로 두개를 확실히 구분해주는 것이 좋기 때문이다. | . | 가능한 한 실패 원자적으로 만들라 . | 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다. | 실패 원자적으로 만드는 방법 | . | 불변 객체로 설계하는 것 : 실패하더라도 변하지 않으므로 객체가 불안정한 상태에 빠지지 않는다. | 작업 수행에 앞서 매개변수의 유효성을 검사하는 것 | 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것 | 작업도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법 | . | 예외를 무시하지 말라. | 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓도록 하자. | . | . try { } catch (TimeoutException | ExecutionException ignored) { // 기본값을 사용한다 } . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#-%EC%98%88%EC%99%B8",
    "relUrl": "/docs/clipping/java/effective_java/#-예외"
  },"32": {
    "doc": "Effective Java",
    "title": ":: 동시성",
    "content": ". | 공유중인 가변 데이터는 동기화해 사용하라 . | 언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다. 즉, 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다는 뜻이다. | 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다. | 여러 스레드가 가변 데이터를 공유한다면 그 데이터는 읽고 쓰는 동작은 반드시 동기화해야한다. 아니면 불변 데이터만 공유하거나 아무것도 공유하지 말자. 가변 데이터는 단일 스레드에서만 쓰도록 하자 | . | 과도한 동기화는 피하라 . | 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안된다 | 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다 | 동기화 영역에서는 가능한 한 일을 적게 하는 것 | . | 쓰레드보다는 실행자, 태스크, 스트림을 애용하라 . | 실행자 | . | 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋다 . | CachedThreadPool은 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행된다. 그래서 무거운 어플리케이션엔 맞지 않다 | . | 무거운 서버라면 Executors.newFixedThreadPool을 사용하거나 ThreadPoolExecutor를 직접 선언하도록 한다. | 자바7에서부터 실행자 프레임워크는 fork-join태스크를 지원한다. - 태스크 | 태스크는 실행자 프레임워크에서 작업단위를 나타내는 추상 개념으로 Runnable, Callable이 있다. | 포크 조인 태스크 . | 포크 조인풀이라는 특별한 실행자 서비스를 실행한다. | ForkJoinTask의 인스턴스는 작은 하위 태스크로 나뉠 수 있고일을 먼저 끝넨 태스크는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수 있다. | . | . | wait와 notify보다는 동시성 유틸리티를 애용하라 . | 동시성 유틸리티의 범주 | . | 실행자 프레임워크 | 동시성 컬렉션(concurrent collection) . | List, Queue, Map 과 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다. | 높은 동시성을 수행하기 위해 각자 내부에서 동기화를 수행한다. | 따라서 동시성 컬렉션에서 동기화를 사용안하게 하는 것은 불가능하고 외부에서 락을 걸면 오히려 성능이 떨어진다. | Collections.synchronizedMap보다 ConcurrentHashMap을 사용하는 것이 훨씬 좋다. 동기화된 맵을 동시성 맵으로 교체하는 것만해도 성능이 극적으로 개선된다. | . | 동기화 장치(synchronizer) . | 스레드가 다른 스레드를 기다릴 수 있게 해서, 서로 작업을 조율할 수 있게 해준다. (CountDownLatch, Semaphore) . | wait와 notify를 써야한다고 하면, wait는 항상 표준 관용구에 따라 while문안에서 호출하도록하자 | 일반적으로 notify보다는 notifyAll을 사용해야 한다. | . | . | . | 쓰레드 안전성 수준을 문서화하라 . | 스레드 안전성이 높은 순서 | . | 불변 (‘@Immutable): 이 클래스의 인스턴스는 상수처럼 외부 동기화가 필요없다(String, Long, BigInteger..등) | 무조건적 스레드 안전 (‘@ThreadSafe): 인스턴스는 수정될 수 있으나, 내부에서 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다(AtomicLong, ConcurrentHashMap) | 조건부 스레드 안전 : 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다.(Collections.synchronized 래퍼 메서드가 반환한 컬렉션들) | 스레드 안전하지 않음(‘@NotThreadSafe) : 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 매커니즘으로 감싸야한다 (ArrayList, HashMap 같은 기본 컬렉션) | 스레드 적대적 : 이 클래스는 모든 메서드 호출이 멀티 스레드에 안전하지 않다. 이 경우 deprecated API로 지정하거나 한다. (generateSerialNumber메서드가 없으면 해당) - 반환 타입만으로 명확히 할 수 없는 정적 팩터리라면 객체의 스레드 안전성을 문서화해야한다 - 열거 타입은 굳이 불변으로 안써도 된다 | . | 지연 초기화는 신중히 사용하라 . | 지연 초기화란? | . | 필드이 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법 - 지연 초기화는 양날의 검이다. 클래스 또는 인스턴스 생성 시의 초기화 비용은 줄지만 지연 초기화하는 필드에 접근하는 비용은 커진다. - 멀티 스레드 환경에서는 지연 초기화해야하는 필드를 둘 이상의 스레드가 공유한다면 반드시 동기화해야 한다. - 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다. - 지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자 | . | . private FieldType field; private synchronized FieldType getField() { if (field == null) rield = computeFieldValue(); return field; } . | 성능 때문에 정적 필드를 지연 초기화해야한다면 지연 초기화 홀더 클래스 관용구를 사용하자 | . private static class FieldHolder { static final FieldType field = computeFieldValue(); } private static FieldType getField() { return FieldHolder.field; } // getField가 호출되는 순간 Fieldholder.field가 처음 읽히면서, FieldHolder클래스 초기화가 이뤄진다. // 이 관용구는 getField메서드가 필드에 접근하면서 동기화를 전혀하지 않으니 성능이 느려질게 없다. | 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하라. | 한번은 동기화 없이 검사하고, 한번은 동기화해서 검사한다. 두번 째 검사에서도 필드가 초기화되지 않았을 때만 초기화하도록 한다. | 필드가 초기화된 후로는 동기화하지 않으므로 해당 필드는 반드시 volatile로 선언해야한다. | . | . private volatile FieldType field; private FieldType getField() { FieldType result = field; if (result != null) { // 초기화된 상황에서는 필드를 한번만 읽도록 보장. 첫번째 검사 return result; } synchronized(this) { if (field == null) { // 두 번째 검사 field = computeFieldValue(); } return field; } } . | 대부분의 필드는 지연 초기화가 필요없다. 꼭 지연 초기화를 써야한다면 인스턴스 필드에는 이중검사 관용구를, 정적 필드에는 지연 초기화 홀더 클래스 관용구를 사용하자. | . | 프로그램의 동작을 스레드 스케쥴러에 기대지 말라 . | 여러 스레드가 실행중이면 운영체제의 스레드 스케쥴러가 어떤 스레드를 얼마나 오래 실행할지 결정한다. 정확성이나 성능이 스레드 스케쥴러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다 | 실행 가능한 스레드 수를 프로세서 수보다 지나치게 많아지지 않게 하는 것이 중요하다. | 스레드가 작업이 완료되면, 다음 작업이 있을 때까지 대기하게 하는 것이 좋다. 즉 스레드 풀을 적절하게 설정하고 작업은 짧게 유지한다. | 스레드는 busy waiting 상태가 되면 안된다. 이 상태는 스레드 스케쥴러에 취약하고 프로세스에 큰 부담을 준다. | 스레드 우선순위나 Thread.yield로 해결하려고 하면 안된다. 이식성도 떨어지고 합리적인 조치가 아니다. | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#-%EB%8F%99%EC%8B%9C%EC%84%B1",
    "relUrl": "/docs/clipping/java/effective_java/#-동시성"
  },"33": {
    "doc": "Effective Java",
    "title": "::직렬화",
    "content": ". | 자바 직렬화의 대안을 찾아라 . | 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다. | . | 크로스-플랫폼 구조화된 데이터 표현 . | json : 텍스트 기반 표현에는 효과적 | 프로토콜 버퍼 . | 자바 직렬화를 피할 수 없다면, 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다. | . | . | 객체 역직렬화 필터링(java.io.ObjectInputFilter)을 사용하자 | . | Serializable을 구현할지는 신중히 결정하라 . | Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다. 직렬화 형태도 하나의 공개 API가 된다. | 직렬화가 클래스 개선을 방해하는 예 | . | 스트림 고유 식별자, 즉 직렬 버전 UID가 없으면 시스템이 런타임에 암호해시 함수를 적용해 자동으로 클래스 안에 생성해 넣는다. 그런데 자동으로 생성되면 나중에 클래스가 수정되면 uid값도 변경되기 때문에 호환성이 꺠져버려 런타임에 InvalidClassException이 발생한다. | 버그와 보안 구멍이 생길 위험이 높아진다. | 직렬화는 언어의 기본 매커니즘을 우회하는 객체 생성 기법인 것이다. 역직렬화는 일반 생성자의 문제가 그대로 적용되는 ‘숨은 생성자’다. 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다는 뜻이다. | . | 해당 클래스의 신 버전을 릴리스할 때 테스트할 것이 늘어난다는 것이다. | 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장해서는 안된다. | 내부클래스는 직렬화를 구현하지 말아야 한다. | . | 커스텀 직렬화 형태를 고려해보라 . | 자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고, 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안하라 | 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 uid를 절대 수정하지말자. | . | readObject 메서드는 방어적으로 작성하라 . | readObject메서드를 작성할 때는 항상 public생성자를 작성하는 자세로 해야한다. | readObject는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야한다. 바이트 스트림이 진짜 직렬화된 인스턴스라고 가정해서는 안된다. | . | 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라. | 불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용하자 | . | . public enum Elvis { INSTANCE; private String[] favoriteSongs = { \"Hound Dog\", \"Heartbreak Hotel\"}; public void printFavorites() { System.out.println(Arrays.toString(favoriteSongs)); } } . | implement Serializable을 추가하면 싱글턴이 아니게 되는데, readResolve기능을 이용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다. 그리고 그 클래스에서 모든 참조 타입 인스턴스 필드를 transient로 선언해야한다. | . | 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라 . | 직렬화를 구현하게 되면 버그와 보안 문제가 일어나게 되는데 그 위험을 줄여줄 기법으로 직렬화 프록시 패턴(serialization proxy pattern)이 있다. | . | . private Object writeReplace() { // 직렬화 프록시 패턴용 writeReplace 메서드 return new SerializationProxy(this); } . | 직렬화 프록시 패턴 단점 . | 클라이언트가 확장할 수 있는 클래스에는 적용할 수 없다 | 객체 그래프에 순환이 있는 클래스에도 적용할 수 없다. | 방어적 복사보다 성능이 안좋다. | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/#%EC%A7%81%EB%A0%AC%ED%99%94",
    "relUrl": "/docs/clipping/java/effective_java/#직렬화"
  },"34": {
    "doc": "Effective Java",
    "title": "Effective Java",
    "content": " ",
    "url": "http://localhost:4000/docs/clipping/java/effective_java/",
    "relUrl": "/docs/clipping/java/effective_java/"
  },"35": {
    "doc": "Elastic Search",
    "title": "Elastic Search",
    "content": " ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch/",
    "relUrl": "/docs/msa/elastic-search/elasticsearch/"
  },"36": {
    "doc": "elasticsearch field add(1)",
    "title": "[기존 데이터에 추가하는 방식]",
    "content": "💡 *데이터가 적고, 서버에 문제가 없을 경우에만 사용합니다. (로컬의 경우에만 진행하도록 합니다.)* 1. 현재 적용된 맵핑 정보를 조회한다. GET attic_ticket/_mapping . 2. 위에서 조회한 맵핑 정보를 참고해서, depth에 맞게 컬럼을 추가한다. PUT attic_ticket/_mappings { \"properties\": { \"customer\" : { \"type\":\"nested\", \"properties\": { \"messengerId\": { // customer에 messengerId 컬럼 추가 \"type\": \"text\" } } } } } . 3. 잘 추가되었는지 확인한다 . GET attic_ticket/_mapping . 4. 기존 데이터에 추가한 필드를 업데이트 한다.( multiple update ) . POST attic_ticket/_update_by_query { \"script\": \"ctx._source.customer.messengerId = ''\" } . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_1/#%EA%B8%B0%EC%A1%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%B6%94%EA%B0%80%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_1/#기존-데이터에-추가하는-방식"
  },"37": {
    "doc": "elasticsearch field add(1)",
    "title": "** (필드가 배열인 경우) **",
    "content": "5-1. 기존 배열 삭제 . POST attic_message/_update_by_query { \"script\": { \"source\": \"ctx._source.remove('metaarray')\" }, \"query\":{ \"bool\": { \"should\": [ { \"terms\": { \"channelUrl\": [ \"92095428-d647-466c-a054-e1e984dd48b1\" ] } } ] } } } . 5-2. 배열 초기화 . POST attic_message/_update_by_query { \"script\": \"ctx._source.metaarray = []\", \"query\":{ \"bool\": { \"should\": [ { \"terms\": { \"channelUrl\": [ \"92095428-d647-466c-a054-e1e984dd48b1\" ] } } ] } } } . 5-3. 배열에 값 추가 . POST attic_message/_update_by_query { \"script\": { \"source\":\"ctx._source.metaarray.add(params)\", \"params\": { \"key\": \"templateMessage\", \"value\":[ \"{~~~~~~~~~~}\" ] } }, \"query\":{ \"bool\": { \"should\": [ { \"terms\": { \"channelUrl\": [ \"92095428-d647-466c-a054-e1e984dd48b1\" ] } } ] } } } . 5. 검증 . | 일부 티켓에만 추가한 필드에 값을 업데이트해본다. | . POST attic_ticket/_update_by_query { \"script\": { \"source\":\"ctx._source.customer.messengerId = 'honggildong'\" }, \"query\":{ // 일부 ticket에만 값을 업데이트하고 \"term\":{ \"ticketId\":\"63af9a77-845b-4ca5-b692-0d3e5cc7d398\" } } } . | 추가한 값으로 검색해본다. | . GET attic_ticket/_search { \"query\" : { \"bool\": { \"should\":[{ \"terms\":{ \"ticketId\":[\"63af9a77-845b-4ca5-b692-0d3e5cc7d398\"],\"boost\":1.0 } }] } } } . 참고) https://esbook.kimjmin.net/04-data/4.3-_bulk . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_1/#-%ED%95%84%EB%93%9C%EA%B0%80-%EB%B0%B0%EC%97%B4%EC%9D%B8-%EA%B2%BD%EC%9A%B0-",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_1/#-필드가-배열인-경우-"
  },"38": {
    "doc": "elasticsearch field add(1)",
    "title": "elasticsearch field add(1)",
    "content": "💡 지금까지 찾아본 방식 중 2가지를 정리 [공통] . 기존 데이터 백업을 진행합니다. 스냅샷 백업 방식은 “여기” 참고하세요. ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_1/",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_1/"
  },"39": {
    "doc": "elasticsearch field add(2)",
    "title": "[Alias를 활용하는 방식]",
    "content": "💡 무중단 방식인 만큼, 데이터가 많은 경우 size를 나눠서 진행하고, 백업은 필수로 합니다. ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#alias%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#alias를-활용하는-방식"
  },"40": {
    "doc": "elasticsearch field add(2)",
    "title": "1. 현재 적용된 맵핑 정보를 조회한다.",
    "content": "GET attic_ticket/_mapping . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#1-%ED%98%84%EC%9E%AC-%EC%A0%81%EC%9A%A9%EB%90%9C-%EB%A7%B5%ED%95%91-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#1-현재-적용된-맵핑-정보를-조회한다"
  },"41": {
    "doc": "elasticsearch field add(2)",
    "title": "2. 위에서 조회한 맵핑 정보를 복사해서, 새로운 필드을 추가하고 새로운 맵핑정보를 가진 인덱스를 생성한다.",
    "content": "PUT attic_ticket_new // attic_ticket_new 인덱스를 생성 { \"mappings\":{ \"properties\" : { \"_class\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } }, \"customer\" : { \"type\" : \"nested\", \"properties\" : { \"messengerId\" : { // messengerId 필드 추가 \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } }, ......(중략)....... } } } . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#2-%EC%9C%84%EC%97%90%EC%84%9C-%EC%A1%B0%ED%9A%8C%ED%95%9C-%EB%A7%B5%ED%95%91-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EB%B3%B5%EC%82%AC%ED%95%B4%EC%84%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%95%84%EB%93%9C%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%98%EA%B3%A0-%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A7%B5%ED%95%91%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#2-위에서-조회한-맵핑-정보를-복사해서-새로운-필드을-추가하고-새로운-맵핑정보를-가진-인덱스를-생성한다"
  },"42": {
    "doc": "elasticsearch field add(2)",
    "title": "3. 잘 추가되었는지 확인한다",
    "content": "GET attic_ticket_new/_mapping . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#3-%EC%9E%98-%EC%B6%94%EA%B0%80%EB%90%98%EC%97%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#3-잘-추가되었는지-확인한다"
  },"43": {
    "doc": "elasticsearch field add(2)",
    "title": "4. 새로 생성한 인덱스로 기존 데이터 복사",
    "content": "💡 document양이 10만이 넘어가면 Kibana로 했을때 504 Gateway timeout발생하게 되므로 비동기로 실행되도록 옵션 wait_for_completion=false를 준다. POST _reindex?wait_for_completion=false // false로 하면 비동기로 실행하겠다는 뜻 { \"source\": { \"index\": \"attic_ticket\" // 원본 인덱스 }, \"dest\": { \"index\": \"attic_ticket_new\" // 필드 추가해서 새로 생성한 인덱스 } } . | _reindex api는 _source가 enable일때만 가능하다(_search하면 enable인지 확인가능) | _reindex는 mapping정보는 복사하지 않고 데이터만 복사하기 때문에 새로운 index쪽에 따로 mapping정보를 맞춰줘야 하는 것. | . 4-1. 데이터 양이 많은 경우, 여러번 나눠서 수행한다. 💡 reindex는 scroll batch이기 때문에, 사이즈를 나눠서 수행한다. (default size는 1000) POST _reindex?wait_for_completion=false { \"source\": { \"index\": \"attic_ticket\" \"size\" : 999 // 나눠서 수행할 크기를 지정한다. }, \"dest\": { \"index\": \"attic_ticket_new\" } } . 4-2. 원본이 원격지에 있는 경우, 원본 데이터 중 일부만 대상으로 하는 경우 . POST _reindex?wait_for_completion=false { \"source\": { \"remote\": { // 원본데이터가 있는 원격지 정보 \"host\": \"https://remotehost:9200\", \"username\": \"user\", \"password\": \"pass\" }, \"index\": \"attic_ticket\", // 원본 인덱스 \"query\": { // 일부 데이터만 복사할 경우 조건 쿼리를 추가한다. \"match\": { \"field_name\": \"field_value\" } } }, \"dest\": { \"index\": \"attic_ticket_new\" // 필드 추가해서 새로 생성한 인덱스 } } . 4-3. 비동기 수행 후, 수행 결과 조회 . GET _tasks . | task번호로 조회한다. | cancellable이 true이면, 수행 중 취소가 가능하다. | . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#4-%EC%83%88%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A1%9C-%EA%B8%B0%EC%A1%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%B5%EC%82%AC",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#4-새로-생성한-인덱스로-기존-데이터-복사"
  },"44": {
    "doc": "elasticsearch field add(2)",
    "title": "5.  원본데이터와 복사데이터 count를 비교해본다.",
    "content": "GET attic_ticket/_count GET attic_ticket_new/_count . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#5--%EC%9B%90%EB%B3%B8%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%99%80-%EB%B3%B5%EC%82%AC%EB%8D%B0%EC%9D%B4%ED%84%B0-count%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B8%EB%8B%A4",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#5--원본데이터와-복사데이터-count를-비교해본다"
  },"45": {
    "doc": "elasticsearch field add(2)",
    "title": "6. 새로 추가한 인덱스에 기존 인덱스의 alias로 교체해야한다.",
    "content": "6-1. attic_ticket에 alias를 추가한다. (삭제되게 되지만, alias를 교체해야하므로 원본에 alias가 있어야한다.) . 💡 alias 이름은 index이름과 동일한 이름으로 지정할 수 없습니다. alias 이름으로도 인덱스 검색이 되어야하므로... POST /_aliases { \"actions\" : [ { \"add\" : { \"index\" : \"attic_ticket\", \"alias\" : \"attic_ticket_alias\" } } ] } . 6-2. 새로 추가한 인덱스에 기존 원본 alias로 교체해준다. (alias add를 먼저 실행하면 동일한 alias를 가진 색인이 2개가 되므로 (거의) 동일한 검색결과가 2건씩 나오게 된다. 반대로 기존 alias를 먼저 지우면 클라이언트에서 검색 요청이 들어왔을 때 해당 alias내지 인덱스가 없으므로 오류가 발생하기 때문에 add와 remove를 동시에 진행) . POST /_aliases { \"actions\" : [ { \"add\": { \"index\": \"attic_ticket_new\", \"alias\": \"attic_ticket\" }, \"remove\" : { \"index\" : \"attic_ticket\", \"alias\" : \"attic_ticket_alias\" } } ] } . 6-3. 새로운 인덱스에 alias가 잘 맵핑되어있는지 확인한다. GET /_alias . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#6-%EC%83%88%EB%A1%9C-%EC%B6%94%EA%B0%80%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%97%90-%EA%B8%B0%EC%A1%B4-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-alias%EB%A1%9C-%EA%B5%90%EC%B2%B4%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#6-새로-추가한-인덱스에-기존-인덱스의-alias로-교체해야한다"
  },"46": {
    "doc": "elasticsearch field add(2)",
    "title": "7. 검증",
    "content": "7-1. 새로운 티켓을 인입 또는 종료시켜본다. 7-2. 새로운 인덱스로 검색해본다. GET attic_ticket/_search // 교체한 alias명으로 검색 { \"query\" : { \"bool\": { \"should\":[{ \"terms\":{ \"ticketId\":[\"f6872447-be1a-4152-8325-7620a6ee084f\"],\"boost\":1.0 } }] } } } . | 검색 결과의 _index가 새로 생성한 인덱스명인지 확인 | . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#7-%EA%B2%80%EC%A6%9D",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#7-검증"
  },"47": {
    "doc": "elasticsearch field add(2)",
    "title": "참고",
    "content": "https://www.elastic.co/kr/blog/changing-mapping-with-zero-downtime . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/#%EC%B0%B8%EA%B3%A0",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/#참고"
  },"48": {
    "doc": "elasticsearch field add(2)",
    "title": "elasticsearch field add(2)",
    "content": "[공통] . 기존 데이터 백업을 진행합니다. 스냅샷 백업 방식은 여기 참고하세요. ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_add_field_2/",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_add_field_2/"
  },"49": {
    "doc": "elasticsearch snapshot create/restore/delete",
    "title": "참고 사이트",
    "content": "https://lovekmg.github.io/2018/12/06/elasticsearch-backup-and-restore/ . https://kay0426.tistory.com/46 . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_backup/#%EC%B0%B8%EA%B3%A0-%EC%82%AC%EC%9D%B4%ED%8A%B8",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_backup/#참고-사이트"
  },"50": {
    "doc": "elasticsearch snapshot create/restore/delete",
    "title": "elasticsearch snapshot create/restore/delete",
    "content": ". | elasticsearch snapshot 기능을 사용 | . (1) snapshot을 했을 경우, 저장할 repository가 필요하다. (2) GET _nodes를 실행시켰을 때 path.repo 값이 있는지 확인한다. (3) (2)가 없는 경우, . 1) elasticsearch.yml에 아래 설정을 추가한다. path.repo: [\"/usr/share/elasticsearch/backup\"] . 2) docker에서 elasticsearch reload한다. 3) 다시 kibana에서 GET _nodes 호출 . (4) repository의 path를 지정했으면, snapshot 리파지토리를 생성한다. PUT _snapshot/ticket_backup { \"type\": \"fs\", \"settings\": { \"location\": \"/usr/share/elasticsearch/backup\", --&gt; path.repo의 경로를 지정해준다. \"compress\": true --&gt; 압축할지 여부로, mapping데이터만 압축되고 data가 압축되는 것은 아님. 디폴트(true) } } . 참고) elasticsearch를 재구동해도 snapshot repository가 영속되도록 하려면, volume에 path.repo를 추가해줘야한다. (5) snapshot 생성 . PUT _snapshot/ticket_backup/ticket_snapshot_210513?wait_for_completion=true // 비동기로 실행 { \"indices\": \"attic_ticket\", // snapshop할 doc으로 , 콤마로 여러개 지정가능. alias명으로 불가 \"ignore_unavailable\": true, // true 값일 경우, missing되거나 closed 된 indices는 snapshot되지 않는다.(기본 값 false) \"include_global_state\": false, \"metadata\": { \"backup_executor\": \"jhsim\" // 추가 정보 } } . (6) snapshot 조회 . GET _snapshot/ticket_backup/_all . (7) snapshot으로 복원 . POST _snapshot/ticket_backup/ticket_snapshot_210513/_restore { \"indices\": \"attic_ticket\", // alias명으로 불가. 지정하지 않으면 전체를 복구한다. \"ignore_unavailable\": true, \"include_global_state\": true, \"rename_pattern\": \"(.+)\", \"rename_replacement\": \"restored_$1\" // indices 이름과 중첩불가. 다른 이름으로 해야한다. } . ** 변경된 indices로 서비스하려면, alias를 활용해서 한다. (8) 복원 조회 . GET /_cat/indices?v . (9) snapshot 삭제 . DELETE _snapshot/ticket_backup/ticket_snapshot_210513 . ",
    "url": "http://localhost:4000/docs/msa/elastic-search/elasticsearch_backup/",
    "relUrl": "/docs/msa/elastic-search/elasticsearch_backup/"
  },"51": {
    "doc": "전락 열거 타입 패턴",
    "title": "전락 열거 타입 패턴",
    "content": ". | 열거형 클래스에 새로운 값을 열거타입에 추가하려면 그 값을 처리하는 case문을 쌍으로 넣어줘야하는 문제가 있다. | 새로운 상수를 추가할 때마다 ‘전략’을 선택하도록 하면 switch문이나 상수별 메서드 구현이 필요없게 된다. | . enum PayrollDay { MONDAY(WEEKDAY), SUNDAY(WEEKEND); private final PayType payType; PayrollDay(PayType payType) { this.payType = payType; } int pay(int minutesWorked, int payRate) { return payType.pay(minutesWorked, payRate); } enum PayType { WEEKDAY { int overtimePay(int minsWorked, int payRate) { return minsWorked &lt;= MIN_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2; } }, WEEKEND { }; abstract int overtimePay(int mins, int payRate); private static final int MINS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate) { int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); } } } . ",
    "url": "http://localhost:4000/docs/patterns/enums_pattern/",
    "relUrl": "/docs/patterns/enums_pattern/"
  },"52": {
    "doc": "Errors",
    "title": "Errors",
    "content": "About some errors that I know. It might be duplicated. Cause to figure out, I read another blog or stackoverflow.com searching for them. I will go on adding the post. ",
    "url": "http://localhost:4000/docs/errors",
    "relUrl": "/docs/errors"
  },"53": {
    "doc": "Etc",
    "title": "Etc,.",
    "content": "Things that I summarize to record about development. ",
    "url": "http://localhost:4000/docs/etc#etc",
    "relUrl": "/docs/etc#etc"
  },"54": {
    "doc": "Etc",
    "title": "Etc",
    "content": " ",
    "url": "http://localhost:4000/docs/etc",
    "relUrl": "/docs/etc"
  },"55": {
    "doc": "Factory Method pattern",
    "title": "Factory Method pattern",
    "content": "예 ) java8 의 Supplier 인터페이스 . ",
    "url": "http://localhost:4000/docs/patterns/factory_method_pattern/",
    "relUrl": "/docs/patterns/factory_method_pattern/"
  },"56": {
    "doc": "Feign",
    "title": "Feign",
    "content": " ",
    "url": "http://localhost:4000/docs/msa/feign/feign/",
    "relUrl": "/docs/msa/feign/feign/"
  },"57": {
    "doc": "com.netflix.client.ClientException",
    "title": "com.netflix.client.ClientException: Load balancer does not have available server for client: aaa",
    "content": "현상) feignclient로 다른 모듈 호출하려고 하는데 못찾을 때 . 오류) . 11:46:24.265 010-exec-3 ERROR e.r.BaseExceptionHandler: 57 handleThrowable [status] 500 INTERNAL_SERVER_ERROR, [code]: 500100, [message] Hystrix command fails and does not a fallback., [detail message] SchemaTranslateClient#translate(StandardMessageCdo) failed and no fallback available. com.netflix.hystrix.exception.HystrixRuntimeException: SchemaTranslateClient#translate(StandardMessageCdo) failed and no fallback available. at com.netflix.hystrix.AbstractCommand$22.call(AbstractCommand.java:822) . at com.netflix.hystrix.AbstractCommand$22.call(AbstractCommand.java:807) . at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onError(OperatorOnErrorResumeNextViaFunction.java:140) . at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87) . at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87) . at com.netflix.hystrix.AbstractCommand$DeprecatedOnFallbackHookApplication$1.onError(AbstractCommand.java:1472) . at com.netflix.hystrix.AbstractCommand$FallbackHookApplication$1.onError(AbstractCommand.java:1397) . at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87) . at rx.observers.Subscribers$5.onError(Subscribers.java:230) . at rx.internal.operators.OnSubscribeThrow.call(OnSubscribeThrow.java:44) . at rx.internal.operators.OnSubscribeThrow.call(OnSubscribeThrow.java:28) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onError(OperatorOnErrorResumeNextViaFunction.java:142) . at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87) . at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87) . at com.netflix.hystrix.AbstractCommand$HystrixObservableTimeoutOperator$3.onError(AbstractCommand.java:1194) . at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.onError(OperatorSubscribeOn.java:80) . at rx.observers.Subscribers$5.onError(Subscribers.java:230) . at rx.internal.operators.OnSubscribeDoOnEach$DoOnEachSubscriber.onError(OnSubscribeDoOnEach.java:87) . at rx.observers.Subscribers$5.onError(Subscribers.java:230) . at com.netflix.hystrix.AbstractCommand$DeprecatedOnRunHookApplication$1.onError(AbstractCommand.java:1431) . at com.netflix.hystrix.AbstractCommand$ExecutionHookApplication$1.onError(AbstractCommand.java:1362) . at rx.observers.Subscribers$5.onError(Subscribers.java:230) . at rx.observers.Subscribers$5.onError(Subscribers.java:230) . at rx.internal.operators.OnSubscribeThrow.call(OnSubscribeThrow.java:44) . at rx.internal.operators.OnSubscribeThrow.call(OnSubscribeThrow.java:28) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) . at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) . at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) . at rx.Observable.unsafeSubscribe(Observable.java:10327) . at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.call(OperatorSubscribeOn.java:100) . at com.netflix.hystrix.strategy.concurrency.HystrixContexSchedulerAction$1.call(HystrixContexSchedulerAction.java:56) . at com.netflix.hystrix.strategy.concurrency.HystrixContexSchedulerAction$1.call(HystrixContexSchedulerAction.java:47) . at org.springframework.cloud.sleuth.instrument.async.TraceCallable.call(TraceCallable.java:70) . at com.netflix.hystrix.strategy.concurrency.HystrixContexSchedulerAction.call(HystrixContexSchedulerAction.java:69) . at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) . at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) . at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) . at java.base/java.util.concurrent.FutureTask.run(FutureTask.java) . at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) . at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) . at java.base/java.lang.Thread.run(Thread.java:835) . Caused by: java.lang.RuntimeException: com.netflix.client.ClientException: Load balancer does not have available server for client: aaa . at org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient.execute(LoadBalancerFeignClient.java:90) . at org.springframework.cloud.sleuth.instrument.web.client.feign.TraceLoadBalancerFeignClient.execute(TraceLoadBalancerFeignClient.java:71) . at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:108) . at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:78) . at feign.hystrix.HystrixInvocationHandler$1.run(HystrixInvocationHandler.java:109) . at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302) . at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298) . at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:46) . … 28 common frames omitted . 해결) springboot로 올릴때 해당 모듈이 pom에 있는지랑. springboot application에 feignclient어노테이션이 있는지를 확인한다. ",
    "url": "http://localhost:4000/docs/errors/feign1/#comnetflixclientclientexception-load-balancer-does-not-have-available-server-for-client-aaa",
    "relUrl": "/docs/errors/feign1/#comnetflixclientclientexception-load-balancer-does-not-have-available-server-for-client-aaa"
  },"58": {
    "doc": "com.netflix.client.ClientException",
    "title": "com.netflix.client.ClientException",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/feign1/",
    "relUrl": "/docs/errors/feign1/"
  },"59": {
    "doc": "java.lang.IllegalStateException...",
    "title": "java.lang.IllegalStateException: RequestParam.value() was empty on parameter 0",
    "content": "원인 : FeignClient로 선언한 adapter에 @RequestParam으로 값을 받아오는 부분에 맵핑을 잘못함. 기존&gt; . @RequestParam(defaultValue =”0”, required = false) int offset, . @RequestParam(defaultValue = “10”, required = false) int limit . 변경&gt; . @RequestParam(“offset”) int offset, . @RequestParam(“limit”) int limit . ",
    "url": "http://localhost:4000/docs/errors/feign2/#javalangillegalstateexception-requestparamvalue-was-empty-on-parameter-0",
    "relUrl": "/docs/errors/feign2/#javalangillegalstateexception-requestparamvalue-was-empty-on-parameter-0"
  },"60": {
    "doc": "java.lang.IllegalStateException...",
    "title": "java.lang.IllegalStateException...",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/feign2/",
    "relUrl": "/docs/errors/feign2/"
  },"61": {
    "doc": "Flyweight pattern",
    "title": "Flyweight pattern",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns/flyweight_pattern/",
    "relUrl": "/docs/patterns/flyweight_pattern/"
  },"62": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: github에서 블로그를 사용하기 위한 사전 준비",
    "content": "** 이대로 하기만 하면 됨 . 왕초보를 위한 Github 블로그 만들기 (1) . ** 오류 1 . remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. push할 때 위의 에러가 나면, . 깃 토큰 인증(Git personal access token) . ** 오류 2 . unable to access ‘/Users/${userName}/.config/git/attributes’: Permission denied . Unable to access ‘git/attributes’ . ** 오류 3 . jekyll을 설치하려고 하다보니 ruby로 되어있어서… 온갖 오류를 다 만났습니다… . ruby는 모르기도 하고…포기할 뻔 . jekyll: command not found . Jekyll - command not found . ** 오류 4 . You don’t have write permissions for the /Library/Ruby/Gems/2.6.0 directory . Mac에서 Gem::FilePermissionError 에러 발생시 해결 방법 . ** 오류 5 . 겨우겨우 ruby버전 업하고 jekyll도 설치해서, 서비스 구동하려고 하니까 또 다른 오류 발생 . jekyll/commands/serve/servlet.rb:3:in `require’: cannot load such file – webrick (LoadError) . 하필 ruby를 3.0.2로 업그레이드 했더니,,, 3.x부터 webrick이 빠졌다고 하네요 ㅠㅜ . 별도로 webrick을 설치해줘야합니다. jekyll 실행 시킬 때 `require’: cannot load such file – webrick (LoadError) 오류가 난다면 bundle add webrick . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-github%EC%97%90%EC%84%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%82%AC%EC%A0%84-%EC%A4%80%EB%B9%84",
    "relUrl": "/docs/etc/gitblog_move/#-github에서-블로그를-사용하기-위한-사전-준비"
  },"63": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 축!",
    "content": "드디어 기본 준비가 끝이 났습니다…… . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%EC%B6%95",
    "relUrl": "/docs/etc/gitblog_move/#-축"
  },"64": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 블로그에 Jekyll 테마 적용하기",
    "content": "이제는 jekyll을 잘 꾸며볼 차례입니다.. 아래 블로그에서 가이드대로 따라하면 됩니다. 왕초보를 위한 Github 블로그 만들기 (2) - 테마 적용(with Jekyll) . 무료버전으로 찾아봤습니다 ㅋㅋ . 저는 이것으로 선택(jekyll-theme-prologue) . GitHub - chrisbobbe/jekyll-theme-prologue: A Jekyll version of the “Prologue” theme by HTML5 UP . :: 오류 1 . 다운받은 테마 파일을 bundle install 하려고 하니까, 다운받은 gemfil과 버전이 안맞았네요 . Fetching gem metadata from https://rubygems.org/......... Resolving dependencies... Bundler could not find compatible versions for gem \"bundler\": In Gemfile: bundler (~&gt; 1.12) Current Bundler version: bundler (2.2.29) Your bundle requires a different version of Bundler than the one you're running. Install the necessary version with `gem install bundler:1.17.3` and rerun bundler using `bundle _1.17.3_ install` . —&gt; gemfile만 원래 파일로 돌려놓고, 덮지 않음 . :: 오류 ?? . Bundler could not find compatible versions for gem \"bundler\": In Gemfile: bundler (~&gt; 1.12) Current Bundler version: bundler (2.2.29) Your bundle requires a different version of Bundler than the one you're running. Install the necessary version with `gem install bundler:1.17.3` and rerun bundler using `bundle _1.17.3_ install` . 이건 gem 을 ‘~&gt;1.12’ 까지 설치하고, gemfile.lock파일 삭제하고 bundle 1.17.3 install 해주고 해서 해결하긴 했는데요… . 삽질을 많이하고 오류를 너무 많이 봐서 다 정리를 못하겠습니다. ㅠㅜ ruby도 삭제하고 다시 설치하고 . 하..포기할 뻔.. 겨우 테마 설치 완료 ^__^ . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-jekyll-%ED%85%8C%EB%A7%88-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/etc/gitblog_move/#-블로그에-jekyll-테마-적용하기"
  },"65": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: gitblog에 광고 적용하기",
    "content": "기존에 사용하던 애드센스가 있었기 때문에, 어렵지 않게 광고를 재개할 수 있었습니다. 관리페이지에서 새로운 주소로 사이트를 추가하고 스크립트를 include\\head_custom.html하위에 추가하면 끝. 참고) . 블로그 수익 애드 센스 광고 달기 . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-gitblog%EC%97%90-%EA%B4%91%EA%B3%A0-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/etc/gitblog_move/#-gitblog에-광고-적용하기"
  },"66": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: DNS 적용하기",
    "content": "gitblog를 생성하면, username으로 기본 주소가 되기 때문에 도메인네임을 추가해서 포워딩서비스를 하는 것이 좋습니다. | 저는 freenom을 사용하고 있어서 freenom에 무료 도메인 하나 더 추가생성했습니다. | freenom에 github와의 nameserver를 설정해야하는데요. 아래 블로그 참고하면 간단합니다. | . | [도메인 무료로 SSL/TLS(HTTPS) 얻는 법 | Freenom &amp; GitHub Pages](https://m.blog.naver.com/desbey7/222092439777) | . dns와 sitemap관계 . 아무리 sitemap을 수정해도 가져올 수 없다고만 나와서 수동 등록까지 했는데요. https://itgall.com/programming/236207 글 읽고, 다시 cf도메인 연결을 삭제하고 github.io로 돌려놨습니다. ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-dns-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/etc/gitblog_move/#-dns-적용하기"
  },"67": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 구글 검색엔진에 노출시키기",
    "content": "step-9-구글-검색-가능하게-하기 . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%EA%B5%AC%EA%B8%80-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%97%90-%EB%85%B8%EC%B6%9C%EC%8B%9C%ED%82%A4%EA%B8%B0",
    "relUrl": "/docs/etc/gitblog_move/#-구글-검색엔진에-노출시키기"
  },"68": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 파비콘 적용",
    "content": "저는 니아 언더 세븐의 니아 이미지를 추출해서 적용했습니다. [Github Blog] 파비콘(Favicon) 세팅하기 . header코드에 이미 선언되어 있어서, 생성한 파비콘 파일을 기존과 동일한 이름으로 교체만 해주었습니다!! . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%ED%8C%8C%EB%B9%84%EC%BD%98-%EC%A0%81%EC%9A%A9",
    "relUrl": "/docs/etc/gitblog_move/#-파비콘-적용"
  },"69": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 댓글 추가",
    "content": "에드고시에 거듭 실패해서 이런 저런 이유를 찾던 중, 댓글기능이 없어서 그럴 수도 있단 글을 읽고 jekyll에 댓글 기능을 추가했습니다. 자세한 내용은 아래 블로그를 참고해주세요. 되게 간단하네요! utterance 댓글 설치 . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%EB%8C%93%EA%B8%80-%EC%B6%94%EA%B0%80",
    "relUrl": "/docs/etc/gitblog_move/#-댓글-추가"
  },"70": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 태그 추가",
    "content": "아직도 할 것이 많네요 ㅋㅋㅋㅋ 태그가 등록된다면 검색될 확률이 높아질 것 같아서 태그도 추가했습니다. 태그 추가 . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%ED%83%9C%EA%B7%B8-%EC%B6%94%EA%B0%80",
    "relUrl": "/docs/etc/gitblog_move/#-태그-추가"
  },"71": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 검색엔진 등록",
    "content": "구글 서치엔진 . | 저는 jekyll-sitemap 플러그인을 사용해서 sitemap.xml을 만들었는데요. 아무리해도 “사이트맵을 읽을 수 없음”만 표시되어서 잘못 만들어졌다 했는데요. | 처음엔 last_modified_at가 없어서 그런듯 싶어서, layout도 post로 변경하고 추가해줬습니다. | 사이트맵 validation 체크 사이트에서도 체크했는데요. 정상으로 표시됩니다. | . | . ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EB%93%B1%EB%A1%9D",
    "relUrl": "/docs/etc/gitblog_move/#-검색엔진-등록"
  },"72": {
    "doc": "notion에서 gitblog로 이사",
    "title": ":: 마무리",
    "content": "조금씩 notion이나 에버노트 내용을 옮기고 있습니다. ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/#-%EB%A7%88%EB%AC%B4%EB%A6%AC",
    "relUrl": "/docs/etc/gitblog_move/#-마무리"
  },"73": {
    "doc": "notion에서 gitblog로 이사",
    "title": "notion에서 gitblog로 이사",
    "content": " ",
    "url": "http://localhost:4000/docs/etc/gitblog_move/",
    "relUrl": "/docs/etc/gitblog_move/"
  },"74": {
    "doc": "Home",
    "title": "Summary List",
    "content": ". ",
    "url": "http://localhost:4000/#summary-list",
    "relUrl": "/#summary-list"
  },"75": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"76": {
    "doc": "Intercepting Filter Pattern",
    "title": "Intercepting Filter Pattern",
    "content": "Interception Filter Pattern . | 체인으로 묶인 필터를 통과하면서 최종적으로 Target 클래스에 도달하도록 한다. | 전처리/후처리를 수행하려고 하는 경우 사용 | . ",
    "url": "http://localhost:4000/docs/patterns/intercepting_filter_pattern/",
    "relUrl": "/docs/patterns/intercepting_filter_pattern/"
  },"77": {
    "doc": "Intercepting Filter Pattern",
    "title": "Entity.",
    "content": "Filter:: . 실제로 필터작업을 구현하고, 실행 . public class AppChannelFilter implements BusinessMessageFilter { // 특정 App채널만 유효하도록 필터링 private final AppChannelTypeValidator appChannelTypeValidator; @Override public void execute(ConversationMessage conversationMessage) { appChannelTypeValidator.validate(); } } . Filter Chain:: . 여러 필터들을 순서대로 실행하기 위해 체인으로 묶음 . Target:: . 모든 필터가 통과되면 최종적으로 실행될 엔티티 . Filter Manager:: . 여러 필터들과 필터 체인을 연결 . public class BusinessMessageFilterManager { private final List&lt;BusinessMessageFilter&gt; businessMessageFilters; public void execute(ConversationMessage conversationMessage){ for (BusinessMessageFilter businessMessageFilter : businessMessageFilters) { businessMessageFilter.execute(conversationMessage); } } } . Client:: . 필터요청하는 엔티티 . public class BtalkMessageFilterExecutor { private final BusinessMessageFilterManager businessMessageFilterManager; public void filter(ConversationMessage conversationMessage) { businessMessageFilterManager.execute(conversationMessage); } } . 참고. https://www.tutorialspoint.com/design_pattern/intercepting_filter_pattern.htm . ",
    "url": "http://localhost:4000/docs/patterns/intercepting_filter_pattern/#entity",
    "relUrl": "/docs/patterns/intercepting_filter_pattern/#entity"
  },"78": {
    "doc": "Java",
    "title": "Java",
    "content": " ",
    "url": "http://localhost:4000/docs/clipping/java/java/",
    "relUrl": "/docs/clipping/java/java/"
  },"79": {
    "doc": "header contains multiple values...",
    "title": "header contains multiple values ‘*, *’, but only one is allowed",
    "content": "header contains multiple values ‘*, *’, but only one is allowed . 라고 크롬콘솔에 찍힐때 . response.addheader를 똑같은 값으로 두번한건 아닌지 체크필요. 중복선언시 저런 에러난다. ",
    "url": "http://localhost:4000/docs/errors/java1/#header-contains-multiple-values---but-only-one-is-allowed",
    "relUrl": "/docs/errors/java1/#header-contains-multiple-values---but-only-one-is-allowed"
  },"80": {
    "doc": "header contains multiple values...",
    "title": "header contains multiple values...",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/java1/",
    "relUrl": "/docs/errors/java1/"
  },"81": {
    "doc": "Unsatisfied dependency expressed through constructor parameter 8; nested exception...",
    "title": "Unsatisfied dependency expressed through constructor parameter 8; nested exception…",
    "content": "오류 : Unsatisfied dependency expressed through constructor parameter 8; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘TestAdapter’: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalStateException: Method find not annotated with HTTP method type (ex. GET, POST) . 원인:TestAdapter에 부모가 선언하지 않은 이름의 메소드로 선언되어있어서 그러함. 즉 부모에 있는데TestAdapter에 구현체가 없어서 나오는 에러 . ",
    "url": "http://localhost:4000/docs/errors/java2/#unsatisfied-dependency-expressed-through-constructor-parameter-8-nested-exception",
    "relUrl": "/docs/errors/java2/#unsatisfied-dependency-expressed-through-constructor-parameter-8-nested-exception"
  },"82": {
    "doc": "Unsatisfied dependency expressed through constructor parameter 8; nested exception...",
    "title": "Unsatisfied dependency expressed through constructor parameter 8; nested exception...",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/java2/",
    "relUrl": "/docs/errors/java2/"
  },"83": {
    "doc": "Can't generate resourceBase as part of webapp tmp dir name",
    "title": "Can’t generate resourceBase as part of webapp tmp dir name: java.lang.NullPointerException",
    "content": "현상) 인텔리제이에서 application으로 jetty올리는데 에러가 나면서 안올라갈때 . 오류) [09-29 09:01:17.454] WARN [main] [o.e.j.w.WebInfConfiguration.getCanonicalNameForWebAppTmpDir] 627 - Can’t generate resourceBase as part of webapp tmp dir name: java.lang.NullPointerException . [09-29 09:01:17.665] WARN [main] [o.e.j.w.WebAppContext.doStart] 514 - Failed startup of context o.e.j.w.WebAppContext@17695df3{/router,[],null} . java.lang.NullPointerException: null . at org.eclipse.jetty.webapp.WebAppContext.getWebInf(WebAppContext.java:844) . at org.eclipse.jetty.webapp.WebInfConfiguration.findWebInfLibJars(WebInfConfiguration.java:708) . at org.eclipse.jetty.webapp.WebInfConfiguration.findJars(WebInfConfiguration.java:689) . at org.eclipse.jetty.webapp.WebInfConfiguration.preConfigure(WebInfConfiguration.java:128) . at org.eclipse.jetty.webapp.WebAppContext.preConfigure(WebAppContext.java:468) . at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:504) . at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) . at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132) . at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114) . at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:61) . at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:163) . at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) . at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132) . at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114) . at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:61) . at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) . at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132) . at org.eclipse.jetty.server.Server.start(Server.java:387) . at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114) . at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:61) . at org.eclipse.jetty.server.Server.doStart(Server.java:354) . at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) . 원인) . 첫번째로, 이 프로젝트랑 상관없는 path의 디렉토리를 옮겼었는데, 그걸 못찾는다고 나온당…그래서 그건 그냥 .idea폴더 날리고 , 프로젝트 재생성 . 두번째로, 어플리케이션 올릴때 Working directory에 %MODULE_WORKING_DIR%이렇게 줘야하는데 없어서,,,, 참고로 $MODULE_DIR$ 에서 %MODULE_WORKING_DIR% 이렇게 바뀜 . ",
    "url": "http://localhost:4000/docs/errors/jetty1/#cant-generate-resourcebase-as-part-of-webapp-tmp-dir-name-javalangnullpointerexception",
    "relUrl": "/docs/errors/jetty1/#cant-generate-resourcebase-as-part-of-webapp-tmp-dir-name-javalangnullpointerexception"
  },"84": {
    "doc": "Can't generate resourceBase as part of webapp tmp dir name",
    "title": "Can't generate resourceBase as part of webapp tmp dir name",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/jetty1/",
    "relUrl": "/docs/errors/jetty1/"
  },"85": {
    "doc": "Jpa",
    "title": "Clipping",
    "content": "jpa 프로그래밍 . ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa/#clipping",
    "relUrl": "/docs/clipping/jpa/jpa/#clipping"
  },"86": {
    "doc": "Jpa",
    "title": "Jpa",
    "content": " ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa/",
    "relUrl": "/docs/clipping/jpa/jpa/"
  },"87": {
    "doc": "store-jpa 모듈을 만들고 나니 Not a managed type 에러 날때",
    "title": "store-jpa 모듈을 만들고 나니 Not a managed type 에러 날때",
    "content": "에러 )11:30:46.596 main WARN stractApplicationContext:557 refresh Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘aaaService’ defined in file []: Unsatisfied dependency expressed through constructor parameter 0; nested exception is at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1341) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1187) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:845) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389) at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1341) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1187) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1251) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1171) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) … 19 common frames omittedCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘internalGatewayRepository’: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Not a managed type: class AAAJpo at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1778) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1251) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1171) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760)… 33 common frames omittedCaused by: java.lang.IllegalArgumentException: Not a managed type: class AAAGatewayJpo at org.hibernate.metamodel.internal.MetamodelImpl.managedType(MetamodelImpl.java:552) at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.(JpaMetamodelEntityInformation.java:74) at org.springframework.data.jpa.repository.support.JpaEntityInformationSupport.getEntityInformation(JpaEntityInformationSupport.java:66) at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getEntityInformation(JpaRepositoryFactory.java:201) at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:151) at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:134) at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:65) at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:305) at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.lambda$afterPropertiesSet$5(RepositoryFactoryBeanSupport.java:297) at org.springframework.data.util.Lazy.getNullable(Lazy.java:211) at org.springframework.data.util.Lazy.get(Lazy.java:94) at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:300) at org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:121) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1837) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1774) ... 44 common frames omittedProcess finished with exit code 1 . [원인] . SpringApplication으로 서비스 올릴 때, scan하는 패키지는 test.www인데 springboot로 올리는 application 파일은 test.www.aaa.boot아래에 있었다 . 이걸 test.www.aaa 하위로 옮기고 나니 해결됨 . ",
    "url": "http://localhost:4000/docs/errors/jpa1/",
    "relUrl": "/docs/errors/jpa1/"
  },"88": {
    "doc": "jpa 프로그래밍",
    "title": "3. 영속성 관리",
    "content": "@DynamicUpdate . 컬럼이 30개 이상이 되면, @DynamicUpdate를 사용한 동적 수정 쿼리가 정적 수정 쿼리보다 빠르다. 하지만 한 테이블에 컬럼이 30개 이상 된다는 것은 테이블 설계상 분리가 적절하게 되지 않았을 가능성이 높다. @SequenceGenerator . SequenceGenterator.allocationSize의 기본값은 50이다. 이는 최적화 때문인데, 만약 하나씩 증가해야한다면 1로 설정하면 된다. @SeqyebceGeberator는 @GeneratedValue 옆에 사용해도 된다. ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#3-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#3-영속성-관리"
  },"89": {
    "doc": "jpa 프로그래밍",
    "title": "4. 엔티티 맵핑",
    "content": "@Column 생략 . int data1; // @Column생략, 자바 기본타입으로 not null로 생성된다. Integer data2; // @Column 생략하면 nullable속성으로 생성된다. 따라서 자바 기본타입에 @Column을 사용하면 nullable = false로 지정하는 것이 안전하다. ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#4-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%B5%ED%95%91",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#4-엔티티-맵핑"
  },"90": {
    "doc": "jpa 프로그래밍",
    "title": "5. 연관관계 매핑 기초",
    "content": "양방향 매핑 . 양방향 매핑시에는 무한 루프에 빠지지 않게 조심해야한다. 예를 들어 Member.toString()에서 getTeam()을 호출하고 Team.toString()에서 getMember()를 호출하면 무한 루프에 빠질 수 있다. 이런 문제는 엔티티를 JSON으로 변환할 때 자주 발생한다. ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-%EA%B8%B0%EC%B4%88",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#5-연관관계-매핑-기초"
  },"91": {
    "doc": "jpa 프로그래밍",
    "title": "6. 다양한 연관관계 매핑",
    "content": "일대다 . | 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자. | 관계형 데이터베이스 특성상 외래키는 항상 다 쪽에 있다. 그러므로 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다. 이런 이유로 @ManyToOne에는 mappedBy속성이 없다. | . ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#6-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#6-다양한-연관관계-매핑"
  },"92": {
    "doc": "jpa 프로그래밍",
    "title": "7. 고급 매핑",
    "content": "복합키와 식별 관계 매핑 . | 복합 키에는 @GenerateValue를 사용할 수 없다. 복합 키를 구성하는 여러 컬럼 중 하나에도 사용할 수 없다. | . ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#7-%EA%B3%A0%EA%B8%89-%EB%A7%A4%ED%95%91",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#7-고급-매핑"
  },"93": {
    "doc": "jpa 프로그래밍",
    "title": "9. 값 타입",
    "content": "임베디드 타입(복합 값 타입) . | 임베디드 타입은 기본 생성자가 필수다. | 임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하므로 엔티티와 임베디드 타입의 관계를 UML로 표현하면 컴포지션 관계가 된다 | 하이버네이트는 임베디드 타입을 컴포넌트라고 한다. | . ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#9-%EA%B0%92-%ED%83%80%EC%9E%85",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#9-값-타입"
  },"94": {
    "doc": "jpa 프로그래밍",
    "title": "12. 스프링 데데이이터 JPA",
    "content": "쿼리 메소드 기능 . | 스프링 데이터 JPA 쿼리 생성 기능 | . ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#12-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EB%8D%B0%EC%9D%B4%EC%9D%B4%ED%84%B0-jpa",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#12-스프링-데데이이터-jpa"
  },"95": {
    "doc": "jpa 프로그래밍",
    "title": "14. 컬렉션과 부가  기능",
    "content": "리스너 . | 엔티티의 생명주기에 따른 이벤트를 처리할 수 있다. | 방법 . | 엔티티에 직접 이벤트를 적용하는 방법(@PostPersist, @PostLoad…) | 별도의 리스너 등록 @EntityListener(DuckListener.class) Public class Duck { ... } public class DuckListener { @PrePersist private void prePersist(Object obj) { } @PostPersist private void postPersist(Object obj) { } } . | 기본 리스너 사용 . | 모든 엔티티에 적용하는 경우라면 기본 리스너로 등록하면 된다. | . | . | . ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/#14-%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC-%EB%B6%80%EA%B0%80--%EA%B8%B0%EB%8A%A5",
    "relUrl": "/docs/clipping/jpa/jpa_programming/#14-컬렉션과-부가--기능"
  },"96": {
    "doc": "jpa 프로그래밍",
    "title": "jpa 프로그래밍",
    "content": ". ",
    "url": "http://localhost:4000/docs/clipping/jpa/jpa_programming/",
    "relUrl": "/docs/clipping/jpa/jpa_programming/"
  },"97": {
    "doc": "애플 Symantec Root 인증서 제거로 인한 인증서 갱신",
    "title": "애플 Symantec Root 인증서 제거로 인한 인증서 갱신",
    "content": "에러 : PKIX path building failed . 원인 . | 애플에서 symantec root인증서 제거해서, 인증불가 발생 | JRE 1.8.0_101 미만인 경우 발생 | . 조치 . | JRE 1.8.0_101 이상으로 버전업 | 인증서 추가 | . Java - PKIX path building failed . ",
    "url": "http://localhost:4000/docs/errors/jre1/",
    "relUrl": "/docs/errors/jre1/"
  },"98": {
    "doc": "Timeout of 60000ms expired before the position...",
    "title": "kafdrop 보려는데 Timeout of 60000ms expired before the position for partition retry-assignment-2 could be determined 에러날 때",
    "content": "현상) kafdrop에 접속해서 스트림보려는데, 에러날때 . 애러) . ",
    "url": "http://localhost:4000/docs/errors/kafka1/#kafdrop-%EB%B3%B4%EB%A0%A4%EB%8A%94%EB%8D%B0-timeout-of-60000ms-expired-before-the-position-for-partition-retry-assignment-2-could-be-determined-%EC%97%90%EB%9F%AC%EB%82%A0-%EB%95%8C",
    "relUrl": "/docs/errors/kafka1/#kafdrop-보려는데-timeout-of-60000ms-expired-before-the-position-for-partition-retry-assignment-2-could-be-determined-에러날-때"
  },"99": {
    "doc": "Timeout of 60000ms expired before the position...",
    "title": "Internal Server Error",
    "content": "A 500 error has occurred: Request processing failed; nested exception is org.apache.kafka.common.errors.TimeoutException: Timeout of 60000ms expired before the position for partition retry-assignment-2 could be deter . 원인) host에 주소가 잘못박혀있거나.. 디폴트(60000ms) 로딩시간을 초과했다거나 할때 발생 . 해결) 타임아웃 늘리려면, ProducerConfig.MAX_BLOCK_MS_CONFIG 설정을 주면 된다. 아니면 도커에 컨테이너 삭제하고 다시 deploy . [참고] . stackoverflow.com/a/60068634/14257397 . org.apache.kafka.common.errors.TimeoutException I have two broker 1.0.0 kafka cluster and I am running 1.0.0 kafka stream API application against this kafka.I increased the producer request.timeout.ms to 5 minutes to fix producer Timeoutexceptio… stackoverflow.com . ",
    "url": "http://localhost:4000/docs/errors/kafka1/#internal-server-error",
    "relUrl": "/docs/errors/kafka1/#internal-server-error"
  },"100": {
    "doc": "Timeout of 60000ms expired before the position...",
    "title": "Timeout of 60000ms expired before the position...",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/kafka1/",
    "relUrl": "/docs/errors/kafka1/"
  },"101": {
    "doc": "org.apache.kafka.common.errors.SerializationException",
    "title": "org.apache.kafka.common.errors.SerializationException: Error deserializing key/value for partition",
    "content": "[에러] . 15:04:41.660 er#1-0-C-1 ERROR .k.l.LoggingErrorHandler: 37 handle Error while processing: nullorg.apache.kafka.common.errors.SerializationException: Error deserializing key/value for partition event.message-0 at offset 62. If needed, please seek past the record to continue consumption.Caused by: org.springframework.messaging.converter.MessageConversionException: failed to resolve class name. Class not found [AAA]; nested exception is java.lang.ClassNotFoundException: AAA at org.springframework.kafka.support.converter.DefaultJackson2JavaTypeMapper.getClassIdType(DefaultJackson2JavaTypeMapper.java:138) at org.springframework.kafka.support.converter.DefaultJackson2JavaTypeMapper.toJavaType(DefaultJackson2JavaTypeMapper.java:99) at org.springframework.kafka.support.serializer.JsonDeserializer.deserialize(JsonDeserializer.java:342) at org.apache.kafka.clients.consumer.internals.Fetcher.parseRecord(Fetcher.java:1041) at org.apache.kafka.clients.consumer.internals.Fetcher.access$3300(Fetcher.java:110) at org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords.fetchRecords(Fetcher.java:1223) at org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords.access$1400(Fetcher.java:1072) at org.apache.kafka.clients.consumer.internals.Fetcher.fetchRecords(Fetcher.java:562) at org.apache.kafka.clients.consumer.internals.Fetcher.fetchedRecords(Fetcher.java:523) at org.apache.kafka.clients.consumer.KafkaConsumer.pollForFetches(KafkaConsumer.java:1230) at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1187) at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1115) at brave.kafka.clients.TracingConsumer.poll(TracingConsumer.java:78) at brave.kafka.clients.TracingConsumer.poll(TracingConsumer.java:72) at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:743) at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:700) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.lang.Thread.run(Thread.java:835) . [원인] . kafka consumer가 producer쪽이랑 header가 달라서, 즉 패키지 path가 달라서 그런거임.해결) kafkalistener에 property를 추가하거나 consumer config에 props.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, false);를 추가한다.@KafkaListener(topics = BBB,groupId = BBB + “-push-subscriber”,properties = {“AAA”,”spring.json.use.type.headers:false”}) . [참고] . http://blog.naver.com/PostView.nhn?blogId=simpolor&amp;logNo=221757494878&amp;parentCategoryNo=&amp;categoryNo=218&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postViewhttps://stackoverflow.com/questions/55477941/spring-boot-kafka-class-deserialization-not-in-the-trusted-package . ",
    "url": "http://localhost:4000/docs/errors/kafka2/#orgapachekafkacommonerrorsserializationexception-error-deserializing-keyvalue-for-partition",
    "relUrl": "/docs/errors/kafka2/#orgapachekafkacommonerrorsserializationexception-error-deserializing-keyvalue-for-partition"
  },"102": {
    "doc": "org.apache.kafka.common.errors.SerializationException",
    "title": "org.apache.kafka.common.errors.SerializationException",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/kafka2/",
    "relUrl": "/docs/errors/kafka2/"
  },"103": {
    "doc": "org.springframework.kafka.KafkaException",
    "title": "org.springframework.kafka.KafkaException: Ambiguous methods for payload type",
    "content": "에러 ) . org.springframework.kafka.KafkaException: Ambiguous methods for payload type: class AAA: handle and handle . at org.springframework.kafka.listener.adapter.DelegatingInvocableHandler.findHandlerForPayload(DelegatingInvocableHandler.java:233) . at org.springframework.kafka.listener.adapter.DelegatingInvocableHandler.getHandlerForPayload(DelegatingInvocableHandler.java:168) . at org.springframework.kafka.listener.adapter.DelegatingInvocableHandler.getMethodNameFor(DelegatingInvocableHandler.java:279) . at org.springframework.kafka.listener.adapter.HandlerAdapter.getMethodAsString(HandlerAdapter.java:67) . at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:302) . at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:79) . at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50) . at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter\\(FastClassBySpringCGLIB\\)cde8c01d.invoke() . at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) . at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) . at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) . at org.springframework.cloud.sleuth.instrument.messaging.MessageListenerMethodInterceptor.invoke(TraceMessagingAutoConfiguration.java:324) . at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) . at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) . at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter\\(EnhancerBySpringCGLIB\\)4dfa1e78.onMessage() . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:1275) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:1258) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:1219) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:1200) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:1120) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:935) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:751) . at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:700) . at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) . at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) . at java.base/java.lang.Thread.run(Thread.java:835) . Process finished with exit code -1 . 원인) 내가 handle메소드 인자를 Object타입으로 받은거랑 MessageCreated로 받은걸 두개 생성해서… 어디에 매핑할지 모호하다는 에러임. Object인자로 받는 메소드를 지우자 . ",
    "url": "http://localhost:4000/docs/errors/kafka3/#orgspringframeworkkafkakafkaexception-ambiguous-methods-for-payload-type",
    "relUrl": "/docs/errors/kafka3/#orgspringframeworkkafkakafkaexception-ambiguous-methods-for-payload-type"
  },"104": {
    "doc": "org.springframework.kafka.KafkaException",
    "title": "org.springframework.kafka.KafkaException",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/kafka3/",
    "relUrl": "/docs/errors/kafka3/"
  },"105": {
    "doc": "Kakao Vision API Test",
    "title": "카카오 비전 API 테스트",
    "content": " ",
    "url": "http://localhost:4000/docs/sub-projects/kakao_vision_api_test/#%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B9%84%EC%A0%84-api-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    "relUrl": "/docs/sub-projects/kakao_vision_api_test/#카카오-비전-api-테스트"
  },"106": {
    "doc": "Kakao Vision API Test",
    "title": "Kakao Vision API Test",
    "content": " ",
    "url": "http://localhost:4000/docs/sub-projects/kakao_vision_api_test/",
    "relUrl": "/docs/sub-projects/kakao_vision_api_test/"
  },"107": {
    "doc": "Keycloak",
    "title": "Keycloak 적용 검토",
    "content": "검토 기간 : 2020.03 ~ 2020.05 . 검토 내용 . | keycloak 사용 및 분석 | keycloak 적용시 장단점 | 기타 제약사항 | 결과적으로 자체 개발할 것인지 keycloak을 적용할 것인지 | . 검토 결과 . | 검토 결과 보고서 참고 | . Keycloak_poc결과보고서.zip . ",
    "url": "http://localhost:4000/docs/sub-projects/keyclock/#keycloak-%EC%A0%81%EC%9A%A9-%EA%B2%80%ED%86%A0",
    "relUrl": "/docs/sub-projects/keyclock/#keycloak-적용-검토"
  },"108": {
    "doc": "Keycloak",
    "title": "Keycloak",
    "content": " ",
    "url": "http://localhost:4000/docs/sub-projects/keyclock/",
    "relUrl": "/docs/sub-projects/keyclock/"
  },"109": {
    "doc": "let's encrypt ssl",
    "title": "let’s encrypt with (window, springboot)",
    "content": "로컬(윈도우)에서 springboot 어플리케이션에 ssl을 추가해서 테스트해볼 일이 생겼다. 무료 ssl로 let’s encrypt를 활용하기로 하고 설치 및 적용해봄 . | let’s encrypt는 certbot을 이용해서 설치하면 된다. | 아래 페이지로 이동해서 certbot install파일을 내려받는다. (다운로드) | . Certbot Instructions . | 관리자 권한으로 cmd창을 열고 아래 명령어를 쳐서 잘 설치된건지 확인한다. | . C:\\WINDOWS\\system32&gt; certbot --help . | dns 등록 | . freenom 이용함 (무료 dns) . | dns까지 준비되었다면, ssl을 생성한다. (dns가 없다면, 중간에 실패난다.) | . C:\\WINDOWS\\system32&gt;certbot certonly --standalone Saving debug log to C:\\Certbot\\log\\letsencrypt.log Please enter the domain name(s) you would like on your certificate (comma and/or space separated) (Enter 'c' to cancel): ~~~~~.~~~~ (dns주소 입력) Requesting a certificate for ~~~~~.~~~~ Successfully received certificate. Certificate is saved at: C:\\Certbot\\live\\~~~~~.~~~~fullchain.pem Key is saved at: C:\\Certbot\\live\\~~~~~.~~~~\\privkey.pem This certificate expires on 2022-02-17. These files will be updated when the certificate renews. Certbot has set up a scheduled task to automatically renew this certificate in the background. 참조) 자세한 내용은 아래 블로그 참고 . SpringBoot - Let’s Encrypt로 무료 SSL인증서를 발급받아 SpringBoot에 적용하기(Https) . | 생성한 ssl을 윈도우 폴더에 위치시키고 yml파일을 수정한다. | . server: port: 19010 ssl: enabled: true key-store: ~~~.jks key-store-type: \"JKS\" 또는 \"PKCS12\" 지정 key-store-password: ~~~~~~~~ 인증서 암호 key-alias: 선택항목으로 alias또는 CN명 trust-store: 선택항목 trust-store-password: 선택항목 . | 그리고 @SpringBootApplication파일을 run시킨다. | 내부망에 있다보니, lte로 테스트했을때, 유효한 인증서로 보였는데, line developers의 webhook url로 등록하고 verify하니까 아래 에러가 발생했다. | . An SSL connection error occurred. Confirm that your webhook URL uses HTTPS and has an SSL/TLS certificate issued by a root certification authority that's widely trusted by most browsers . 뭔가 유효하지 않은 느낌이다. | 인증서 유효성 체크사이트(https://www.digicert.com/help/) 에서 체크해본다. —&gt; 유효하지 않다고 나옴. | 브라우저에서 ip로 호출해보니 “ERR_CERT_COMMON_NAME_INVALID”라고 나온다. —&gt; 발급대상과 일치하지 않다는 에러라고 한다. | 포트를 19010에서 443으로 변경하고 다시 digicert에서 검사돌려보니 “TLS Certificate is not trusted” 라고 나온다. —&gt; 인증서 체인을 잘못 건것으로 keytool -list -v -keystore keystore.jks실행시켜서 인증서 개수가 3개 인지 확인한다. | . ",
    "url": "http://localhost:4000/docs/sub-projects/lets_encrypt_ssl/#lets-encrypt-with-window-springboot",
    "relUrl": "/docs/sub-projects/lets_encrypt_ssl/#lets-encrypt-with-window-springboot"
  },"110": {
    "doc": "let's encrypt ssl",
    "title": "let's encrypt ssl",
    "content": " ",
    "url": "http://localhost:4000/docs/sub-projects/lets_encrypt_ssl/",
    "relUrl": "/docs/sub-projects/lets_encrypt_ssl/"
  },"111": {
    "doc": "Line messaging API 적용 노트",
    "title": "Line messaging API 적용 노트",
    "content": ". | webhook 설정 - ssl설정 . | controller작성 . | . 기존 프로젝트에 line 메시징 API만 적용해야하는 환경이라, 라인sdk에서 적용한 스프링버전보다 높은 상황 . 자바는 컴파일은 1.8, . 런타임은 12로 되는 상황 . 간단한 컨트롤러 작성 . @Slf4j @RestController @LineMessageHandler public class LineMessageController { @EventMapping public void handleTextMessageEvent(MessageEvent&lt;TextMessageContent&gt; event) { log.info(\"event: \" + event); final String originalMessageText = event.getMessage().getText(); //return new TextMessage(originalMessageText); } @EventMapping public void handleDefaultMessageEvent(Event event) { System.out.println(\"event: \" + event); } } . 에러1) . 14:34:33.586 010-exec-6 ERROR ineMessageHandlerSupport:217 dispatch Unsupported event type. MessageEvent(replyToken=3406d4539061400ca6d199bc2bad16e6, source=UserSource(userId=Uec5b4b45de71961100290f7a7ff61d0a), message=TextMessageContent(id=15206625437201, text=123, emojis=null, mention=null), timestamp=2021-12-07T05:34:32.441Z, mode=ACTIVE) java.lang.UnsupportedOperationException: Unsupported event type. MessageEvent(replyToken=3406d4539061400ca6d199bc2bad16e6, source=UserSource(userId=Uec5b4b45de71961100290f7a7ff61d0a), message=TextMessageContent(id=15206625437201, text=123, emojis=null, mention=null), timestamp=2021-12-07T05:34:32.441Z, mode=ACTIVE) at com.linecorp.bot.spring.boot.support.LineMessageHandlerSupport.lambda$dispatchInternal$6(LineMessageHandlerSupport.java:226) at java.util.Optional.orElseThrow(Optional.java:290) at com.linecorp.bot.spring.boot.support.LineMessageHandlerSupport.dispatchInternal(LineMessageHandlerSupport.java:226) at com.linecorp.bot.spring.boot.support.LineMessageHandlerSupport.dispatch(LineMessageHandlerSupport.java:213) at com.linecorp.bot.spring.boot.support.LineMessageHandlerSupport.lambda$callback$4(LineMessageHandlerSupport.java:206) at java.util.ArrayList.forEach(ArrayList.java:1259) at com.linecorp.bot.spring.boot.support.LineMessageHandlerSupport.callback(LineMessageHandlerSupport.java:205) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) at javax.servlet.http.HttpServlet.service(HttpServlet.java:665) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:750) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at brave.servlet.TracingFilter.doFilter(TracingFilter.java:68) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at brave.servlet.TracingFilter.doFilter(TracingFilter.java:87) at org.springframework.cloud.sleuth.instrument.web.LazyTracingFilter.doFilter(TraceWebServletAutoConfiguration.java:141) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:97) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) . 분석1) springboot로 띄울때, 디버깅해보면, LineMessageHandler를 선언한 클래스는 스프링에 등록되어 있지만, ‘@EventMapping을 선언한 메소드는 찾지 못하는 문제 발생 . 시도1) @SpringBootApplication(scanBasePackages = “~~~~”)가 기존 프로젝트에 추가된 상황이였는데, scan대상이 잘못되고 있는 것인가 해서, scanBasePackages를 제거하고 올리면 성공 . 하지만 scanBasePackages 설정은 다른 컨테이너와의 상속문제로 반드시 필요한 설정이라 뺄 수가 없음 . 시도2) 라인sdk의 echo를 다시 유심히 봤다. 차이는 @RestController뿐. @RestController를 제거해보니 성공 . 정리는 간단했지만, spring 버전차이를 중심으로 디버깅하다보니 삽질이 길었다. 문제는 @RestController 중복선언으로 보인다. LineMessageHandlerSupport.java내용을 보면 거기에도 @RestController를 자체적으로 선언하고 있다. @Slf4j @RestController @Import(ReplyByReturnValueConsumer.Factory.class) @ConditionalOnProperty(name = \"line.bot.handler.enabled\", havingValue = \"true\", matchIfMissing = true) public class LineMessageHandlerSupport { . 해당 파일의 주석으로도 되어있다. class에는 @LineMessageHandler를 method에는 @EventMappinig을 선언하라고… . ",
    "url": "http://localhost:4000/docs/sub-projects/line_messaging/",
    "relUrl": "/docs/sub-projects/line_messaging/"
  },"112": {
    "doc": "Liquibase",
    "title": "Liquibase",
    "content": "검토 배경 . | 사이트 마이그레이션을 용이하게 하려면? | 수동으로 쿼리를 작성하게 되면, 누락되는 항목도 생기고, 버그도 발생 | . liquibase 주요 기능 . | change log | tracking work | . 검토 결과 . Q1. data diff가 가능한가? . | json data가 저장된 컬럼 비교가 가능한가? | . A1. | 자동으로 비교할 수 없고, liquibase db table에 변경이력을 쌓아야만 이력추적을 통해 가능 | 그 외에 다른 database object들에 대한 diff는 이력으로 쌓지 않아도 모두 가능 | ./liquibase --outputFile=mydiff.txt --driver=com.mysql.jdbc.Driver --classpath=lib/mysql-connector-java-8.0.25.jar --url=\"jdbc:mysql://localhost:3306/db1?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8\" --username=root --password=password --referenceUrl=\"jdbc:mysql://localhost:3306/db2?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8\" --referenceUsername=root --referencePassword=password -diffTypes=data diff . [mydiff.txt] Reference Database: root@localhost @ jdbc:mysql://localhost:3306/db2?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8 (Default Schema: db2) Comparison Database: root@localhost @ jdbc:mysql://localhost:3306/db1?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8 (Default Schema: db1) Compared Schemas: db2 -&gt; db1 Product Name: EQUAL Product Version: EQUAL Missing Catalog(s): NONE Unexpected Catalog(s): NONE Changed Catalog(s): NONE Missing Column(s): db2.mocha_survey_questionnaire.C_ACTIVE db2.mocha_survey.C_MESSAGE Unexpected Column(s): db1.mocha_knowledge.C_ACCESS_TYPE db1.mocha_removed_team.C_ALIAS Changed Column(s): db2.mocha_survey_response.C_CREATED_AT order changed from '5' to '4' db2.mocha_survey.C_ENABLED nullable changed from 'false' to 'true' order changed from '6' to '8' Missing Foreign Key(s): NONE Unexpected Foreign Key(s): NONE Changed Foreign Key(s): NONE Missing Index(s): NONE Unexpected Index(s): NONE Changed Index(s): NONE Missing Primary Key(s): NONE Unexpected Primary Key(s): NONE Changed Primary Key(s): NONE Missing Sequence(s): NONE Unexpected Sequence(s): NONE Changed Sequence(s): NONE Missing Table(s): mocha_survey_questionnaire mocha_survey_restrict Unexpected Table(s): crema_active_kakao Changed Table(s): NONE Missing Unique Constraint(s): NONE Unexpected Unique Constraint(s): NONE Changed Unique Constraint(s): NONE Missing View(s): NONE Unexpected View(s): NONE Changed View(s): NONE . 활용 방법 . | 제품의 버전별 DB이력관리가 필요하다면, git log를 변경이력으로 등록하게 해서 활용하는 방법을 생각해볼 수 있다. | . ",
    "url": "http://localhost:4000/docs/sub-projects/liquibase/",
    "relUrl": "/docs/sub-projects/liquibase/"
  },"113": {
    "doc": "Mooc",
    "title": "Mooc",
    "content": "I summarize contents what I’ve learned through Online. udemy, udacity, inflearn, youtube.. so on. ",
    "url": "http://localhost:4000/docs/mooc",
    "relUrl": "/docs/mooc"
  },"114": {
    "doc": "Msa",
    "title": "Summary",
    "content": " ",
    "url": "http://localhost:4000/docs/msa#summary",
    "relUrl": "/docs/msa#summary"
  },"115": {
    "doc": "Msa",
    "title": "Msa",
    "content": "summarized the api/library used within Spring Cloud. ",
    "url": "http://localhost:4000/docs/msa",
    "relUrl": "/docs/msa"
  },"116": {
    "doc": "Node Sass does not yet support your current environment",
    "title": "Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime",
    "content": "react 프로젝트에 package.json을 npm으로 설치하다가 유독 자주 발생하는 에러 ㅠㅜ . 에러 메시지: . Failed to compile./src/components/messages/common/Modal/Modal.scss (./node_modules/css-loader/dist/cjs.js??ref--6-oneOf-5-1!./node_modules/postcss-loader/src??postcss!./node_modules/resolve-url-loader??ref--6-oneOf-5-3!./node_modules/sass-loader/dist/cjs.js??ref--6-oneOf-5-4!./src/components/messages/common/Modal/Modal.scss) Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (83) . 해결 : . $ npm uninstall node-saas &amp;&amp; npm install npde-saas . Error: Node Sass does not yet support your current environment: Windows 64-bit with false . ",
    "url": "http://localhost:4000/docs/errors/node1/#node-sass-does-not-yet-support-your-current-environment-windows-64-bit-with-unsupported-runtime",
    "relUrl": "/docs/errors/node1/#node-sass-does-not-yet-support-your-current-environment-windows-64-bit-with-unsupported-runtime"
  },"117": {
    "doc": "Node Sass does not yet support your current environment",
    "title": "Node Sass does not yet support your current environment",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/node1/",
    "relUrl": "/docs/errors/node1/"
  },"118": {
    "doc": "기타",
    "title": "오버로딩 vs 가변 인수",
    "content": ". | java9의 컬렉션 API 중 List 인터페이스에서 List.of의 오버로드 메소드들이 존재하는 이유 | . → 오버로드 말고 static List of(E... elements) 라고 선언할 수 있었음에도 사용하지 않은 이유 . → 내부적으로 가변 인수는 추가배열을 할당해서 리스트로 감싼다. → 이렇게 되면, 가변인수로 받은 배열을 할당 → 초기화 → gc까지 실행해야하는 비용이 필요하게 된다. 비슷한 예로 Set.of, Map.of 도 마찬가지 . ",
    "url": "http://localhost:4000/docs/clipping/java/oop_1/#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9-vs-%EA%B0%80%EB%B3%80-%EC%9D%B8%EC%88%98",
    "relUrl": "/docs/clipping/java/oop_1/#오버로딩-vs-가변-인수"
  },"119": {
    "doc": "기타",
    "title": "객체지향",
    "content": " ",
    "url": "http://localhost:4000/docs/clipping/java/oop_1/#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5",
    "relUrl": "/docs/clipping/java/oop_1/#객체지향"
  },"120": {
    "doc": "기타",
    "title": ":: 디미터의 법칙 (Law of Demeter)",
    "content": "디미터 법칙은 객체 O의 메소드 m은 다음의 객체들의 타입의 메소드만 호출해야 한다는 법칙이다. | O 객체 자신의 메소드들. (O itself) . | m의 파라미터로 넘어온 객체들의 메소드들.(M’s parameters) . | m 안에서 생성 되거나 초기화된 객체의 메소드들.(Any objects created/instantiated within M) . | O객체의 직접 소유하는 객체의 메소드들.(O’s direct component objects) . | . 5.O객체의 m에서 접근이 가능한 전역변수의 메소드들.(A global variable, accessible by O, in the scope of M) . class Demeter { private A a; private int func() { return 0; } public void example(B b) { C c = new C(); int f = func(); // 1번의 경우 b.invert(); // 2번의 경우 a = new A(); a.setActive(); // 3번의 경우 c.print(); // 4번의 경우 // Static으로 설정된 Setting 변수가 있다고 가정할때. string UserID = GlobalValues.Setting.getUserID(); //5의 경우 } } . 위의 종류에 해당하는 객체의 메소드들만 호출을 해야한다. 그렇지 않으면 유지보수 측면에서 문제점들이 발생한다. 아래의 예를 보면, . objectA.getObjectB().doSomething(); . objectA.getObjectB().getObjectC().doSomething(); . 출처: . https://hongjinhyeon.tistory.com/138 . ",
    "url": "http://localhost:4000/docs/clipping/java/oop_1/#-%EB%94%94%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%B2%95%EC%B9%99-law-of-demeter",
    "relUrl": "/docs/clipping/java/oop_1/#-디미터의-법칙-law-of-demeter"
  },"121": {
    "doc": "기타",
    "title": "기타",
    "content": " ",
    "url": "http://localhost:4000/docs/clipping/java/oop_1/",
    "relUrl": "/docs/clipping/java/oop_1/"
  },"122": {
    "doc": "객체지향의 사실과 오해 정리",
    "title": "[객체지향의 사실과 오해] 정리",
    "content": ". | 협력하는 객체들의 공동체 . | 객체지향의 핵심은 클래스가 아니다. 클래스는 협력에 참여하는 객체를 만드는 데 필요한 구현 매커니즘일 뿐이다. | 클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라. 객체지향은 객체를 지향하는 것이지 클래스를 지향하는 것이 아니다. | . | 이상한 나라의 객체 . | 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다. 2. | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/oop_fact_c/#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-%EC%A0%95%EB%A6%AC",
    "relUrl": "/docs/clipping/java/oop_fact_c/#객체지향의-사실과-오해-정리"
  },"123": {
    "doc": "객체지향의 사실과 오해 정리",
    "title": "객체지향의 사실과 오해 정리",
    "content": " ",
    "url": "http://localhost:4000/docs/clipping/java/oop_fact_c/",
    "relUrl": "/docs/clipping/java/oop_fact_c/"
  },"124": {
    "doc": "Optional 정리",
    "title": ":: orElse(new …) 대신 orElseGet(() → new …)",
    "content": "orElse(new …) 대신 orElseGet(() → new …) 를 사용하도록 설명하는 부분이 있다. 이유는 orElse에 있는 값의 존재유무를 불문하고 무조건 실행되기 때문인데. 아래의 경우는 예외이다. @Slf4j @RequiredArgsConstructor @Service public class KakaoMessageAdapterService { private final List&lt;KakaoMessageAdapterHandler&gt; kakaoMessageAdapterHandlers; private ThirdPartyMessage getThirdPartyMessage(KakaoMessage kakaoMessage) { KakaoMessageAdapterHandler kakaoMessageAdapterHandler = kakaoMessageAdapterHandlers.stream() .filter(handler -&gt; handler.filter(kakaoMessage.getType().getThirdPartyMessageType())) .findFirst() .orElse(kakaoEtcMessageService); return kakaoMessageAdapterHandler.send(kakaoMessage); } } . | flow . | thirdparty messsage type별로 KakaoMessageAdapterHandler를 상속받아서 구현체가 존재한다. | 만약에 특정 type에 구현체가 존재하지 않는다면, kakaoEtcMessageService가 kakaoMessageAdapterHandler의 구현체가 된다. | . | 위의 경우 , filter로 선 체크 후 → findFirst하고 있는데 이미 구현체들을 filter로 통과시키기 때문에 무의미하게 kakaoEtcMessageService를 호출하고 있지 않다. | . ",
    "url": "http://localhost:4000/docs/clipping/java/optional/#-orelsenew--%EB%8C%80%EC%8B%A0-orelseget--new-",
    "relUrl": "/docs/clipping/java/optional/#-orelsenew--대신-orelseget--new-"
  },"125": {
    "doc": "Optional 정리",
    "title": ":: 단지 값을 얻을 목적이라면 Optinal 대신 null 비교",
    "content": "optinal api가 생겼다고, 무조건 wrapping을 한다든지 남용하면 안된다. optional은 비용이 발생하므로 단순 null체크는 null로 하자. ",
    "url": "http://localhost:4000/docs/clipping/java/optional/#-%EB%8B%A8%EC%A7%80-%EA%B0%92%EC%9D%84-%EC%96%BB%EC%9D%84-%EB%AA%A9%EC%A0%81%EC%9D%B4%EB%9D%BC%EB%A9%B4-optinal-%EB%8C%80%EC%8B%A0-null-%EB%B9%84%EA%B5%90",
    "relUrl": "/docs/clipping/java/optional/#-단지-값을-얻을-목적이라면-optinal-대신-null-비교"
  },"126": {
    "doc": "Optional 정리",
    "title": "Optional 정리",
    "content": "참조 블로그 : . effective java에서도 말하고 있지만, optional은 API 클라이언트에게 리턴값이 없음을 알려주는 기능에 초점을 맞춰야한다. 검사예외와 비슷한 취지의 쓰임으로 이해하면 된다. 참조 블로그 본문 내용 중 . ",
    "url": "http://localhost:4000/docs/clipping/java/optional/",
    "relUrl": "/docs/clipping/java/optional/"
  },"127": {
    "doc": "오케스트레이션 vs 코레오그래피",
    "title": "오케스트레이션 vs 코레오그래피",
    "content": "https://happy-coding-day.tistory.com/102?category=896687 . ",
    "url": "http://localhost:4000/docs/patterns/orchestration_vs_choreography/",
    "relUrl": "/docs/patterns/orchestration_vs_choreography/"
  },"128": {
    "doc": "Patterns",
    "title": "Patterns",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns",
    "relUrl": "/docs/patterns"
  },"129": {
    "doc": "current transaction is aborted, commands ignored until end of transaction block",
    "title": "current transaction is aborted, commands ignored until end of transaction block",
    "content": "[현상] . postgresql - jdbc로 커넥션 맺어서 자바에서 ibatis쿼리 실행하는데 아래와 같은 에러가 났다. current transaction is aborted, commands ignored until end of transaction block . | – The error occurred while applying a parameter map. | – Check the . selectNextOne . | – Check the statement (update procedure failed). | – Cause: org.postgresql.util.PSQLException: ERROR: current transaction is aborted, commands ignored until end of transaction block | . at com.ibatis.sqlmap.engine.mapping.statement.MappedStatement.executeQueryWithCallback(MappedStatement.java:201) . at com.ibatis.sqlmap.engine.mapping.statement.MappedStatement.executeQueryForObject(MappedStatement.java:120) . at com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate.queryForObject(SqlMapExecutorDelegate.java:527) . at com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate.queryForObject(SqlMapExecutorDelegate.java:502) . at com.ibatis.sqlmap.engine.impl.SqlMapSessionImpl.queryForObject(SqlMapSessionImpl.java:106) . at org.springframework.orm.ibatis.SqlMapClientTemplate$1.doInSqlMapClient(SqlMapClientTemplate.java:270) . at org.springframework.orm.ibatis.SqlMapClientTemplate.execute(SqlMapClientTemplate.java:200) . … 52 more . [원인] . 위에 처럼 나오면 쿼리에 문법적 오류로 인하여 현재 트랜잭션은 폐기된다는 뜻 . 내 경우는 selectNextOne쿼리가 잘못되었음 . ",
    "url": "http://localhost:4000/docs/errors/postgres1/",
    "relUrl": "/docs/errors/postgres1/"
  },"130": {
    "doc": "Please log in (using, e.g., \"su\") as the (unprivileged) user that will",
    "title": "Please log in (using, e.g., \"su\") as the (unprivileged) user that will",
    "content": "[현상] . Please log in (using, e.g., “su”) as the (unprivileged) user that will . [원인] . 유닉스에 postgresql을 설치하고 나서 su로 로긴해서 ./pg_ctl로 서비스를 시작하려하는데 저런 에러가… . 일본 구글에서 해답을 찾았다. 블로그 http://nobuneko.com/blog/archives/2011/05/postgresqlinitdb_cannot_be_run.html . 해석 . 솔라리스 등에서 initdb를 실행하려고 하면, initdb: cannot be run as root라고 하는 에러메세지가 표시되고 initdb를 실행시킬 수 없게 된다 . 에러메세지를 읽으면, initdb는 root유저로 실행시킬 수 없다는 것을 알게 된다. 이 에러를 해결하려면 root 유저 외의 사용자로 initdb를 실행시키면 된다. 예를 들면, su - postgres에서 postgres유저를 만드니까 initdb를 postgres로 실행시키면된다. 같은 케이스는 아니지만 나도 su - postgres로 올리니까 해결됨. ",
    "url": "http://localhost:4000/docs/errors/postgres2/",
    "relUrl": "/docs/errors/postgres2/"
  },"131": {
    "doc": "Programming Foundations with Python 후기",
    "title": "Programming Foundations with Python 후기",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udacity/python/",
    "relUrl": "/docs/mooc/udacity/python/"
  },"132": {
    "doc": "Programming Foundations with Python 후기",
    "title": "학습후기",
    "content": "파이썬 무식자도 기초를 잡아주는 비기너 강좌입니다. 총 7개의 주제로 이뤄져 있구요. 유다시티의 특징인 퀴즈가 많습니다. 누군가에게 설명하고 캡쳐해서 올리라는 퀴즈도 있습니다… 하지만 꼭 안그래도 됩니다. 저 말고도 많은 이들이 가르칠 사람 없어서, 혼자 학습한 내용을 캡쳐해서 올리기도 합니다. 아니면 블로그에 올리고 그것을 캡쳐해도 괜찮습니다. 어렵지 않게 초심자도 배울수 있는 커리큘럼입니다. 선수학습은 필요없구요. 자바나  OOP에 대한 개념이 있다면 더 빠르게 이해할 수 있을 듯 합니다. ",
    "url": "http://localhost:4000/docs/mooc/udacity/python/#%ED%95%99%EC%8A%B5%ED%9B%84%EA%B8%B0",
    "relUrl": "/docs/mooc/udacity/python/#학습후기"
  },"133": {
    "doc": "Programming Foundations with Python 후기",
    "title": "강의내용 정리",
    "content": "12강. fetch vs axios . ",
    "url": "http://localhost:4000/docs/mooc/udacity/python/#%EA%B0%95%EC%9D%98%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC",
    "relUrl": "/docs/mooc/udacity/python/#강의내용-정리"
  },"134": {
    "doc": "Quality Practice",
    "title": "Quality Practice",
    "content": " ",
    "url": "http://localhost:4000/docs/quality",
    "relUrl": "/docs/quality"
  },"135": {
    "doc": "Feign Retry",
    "title": "feign retry",
    "content": ". | 전역의 ribbon설정을 안쓰고자 함 | docker의 depends on도 방법 | . healthcheck: test: [“CMD”, “curl”, “-f”, “http://localhost:8040/actuator/health”] interval: 10s timeout: 5s retries: 10 . | feignclient 내부 configuration으로 Retryer를 Bean으로 등록해서 backoff제어한다. | . 참고) . 우아한 feign 적용기 - 우아한형제들 기술 블로그 . ",
    "url": "http://localhost:4000/docs/msa/feign/retry/#feign-retry",
    "relUrl": "/docs/msa/feign/retry/#feign-retry"
  },"136": {
    "doc": "Feign Retry",
    "title": "Feign Retry",
    "content": " ",
    "url": "http://localhost:4000/docs/msa/feign/retry/",
    "relUrl": "/docs/msa/feign/retry/"
  },"137": {
    "doc": "SonarQube",
    "title": "SonarQube",
    "content": "https://rules.sonarsource.com/java 기준으로 검출된 코드에 대해서 정리한 것입니다. ",
    "url": "http://localhost:4000/docs/quality/sonarqube/sonarqube/",
    "relUrl": "/docs/quality/sonarqube/sonarqube/"
  },"138": {
    "doc": "Failed to instantiate [javax.servlet.Filter]...",
    "title": "Failed to instantiate [javax.servlet.Filter]...",
    "content": "Failed to instantiate [javax.servlet.Filter]: Factory method ‘springSecurityFilterChain’ threw exception; nested exception is java.lang.NullPointerException 에러 . problems . springboot로 application 올리다가 에러 발생 . error log . 07:54:50.971 main WARN stractApplicationContext:557 refresh **Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'springSecurityFilterChain' defined in class path resource** [org/springframework/security/config/annotation/web/configuration/WebSecurityConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method 'springSecurityFilterChain' threw exception; nested exception is java.lang.NullPointerException 07:54:54.008 main WARN o.a.j.l.DirectJDKLog:173 log The web application [ROOT] appears to have started a thread named [RxIoScheduler-1 (Evictor)] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.base@12.0.2/jdk.internal.misc.Unsafe.park(Native Method) java.base@12.0.2/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:235) java.base@12.0.2/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2123) java.base@12.0.2/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1182) java.base@12.0.2/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) java.base@12.0.2/java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1054) java.base@12.0.2/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1114) java.base@12.0.2/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) java.base@12.0.2/java.lang.Thread.run(Thread.java:835) 07:54:54.037 main ERROR o.s.b.SpringApplication :821 reportFailureApplication run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'springSecurityFilterChain' defined in class path resource [org/springframework/security/config/annotation/web/configuration/WebSecurityConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method 'springSecurityFilterChain' threw exception; nested exception is java.lang.NullPointerException at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:456) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:307) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:845) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389) at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) at xxx.XXXApplication.main(XXXApplication.java:18) Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method 'springSecurityFilterChain' threw exception; nested exception is java.lang.NullPointerException at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ... 21 common frames omitted **Caused by: java.lang.NullPointerException: null** at xxx.WebSecurityConfig.configure(**WebSecurityConfig.java:19**) at xxx.WebSecurityConfig.configure(WebSecurityConfig.java:10) at xxx.WebSecurityConfig$$EnhancerBySpringCGLIB$$5aba962.configure(&lt;generated&gt;) at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.configure(AbstractConfiguredSecurityBuilder.java:384) at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:330) at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:41) at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:104) at org.springframework.security.config.annotation.web.configurationWebSecurityConfiguration$$EnhancerBySpringCGLIB$$3d7c30de.CGLIB$springSecurityFilterChain$3(&lt;generated&gt;) at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$3d7c30de$$FastClassBySpringCGLIB$$8dd86ea6.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$3d7c30de.springSecurityFilterChain(&lt;generated&gt;) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:567) at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ... 22 common frames omitted Process finished with exit code 1 . cause . 에러의 npe부분을 보면 springboot올릴때, WebSecurityConfig를 읽어가도록 했는데. WebSecurityConfig에서 읽어갈 설정이 yml에 없어서 널포인트 나는 것…. solved . 본인의 경우는 profile을 달리했는데, 그걸 서비스 올릴때 지정안해줘서 디폴트 yml보고 올라가다가 해당 security설정이 없어서 그런거라…profile을 지정해주면 된다. reference . stackoverflow.com/a/4952938 참고 . ",
    "url": "http://localhost:4000/docs/errors/spring1/",
    "relUrl": "/docs/errors/spring1/"
  },"139": {
    "doc": "PathVariable annotation was empty on param 0.",
    "title": "PathVariable annotation was empty on param 0.",
    "content": "Cause) @PathVariable(“id”) 일케 해야하는데, 그냥 @PathVariable이것만 함 . Log) . org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘aaa’ defined in file [aaa.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘bbb’ defined in file [bbb.class]: Unsatisfied dependency expressed through constructor parameter 9; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘CCCClient’: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalStateException: PathVariable annotation was empty on param 0. at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) . at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1341) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1187) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) . at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) . at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) . at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) . at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:845) . at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) . at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) . at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) . CCCOperatorClient’: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalStateException: PathVariable annotation was empty on param 0. at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) . at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1341) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1187) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) . at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) . at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) . at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) . at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) . at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1251) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1171) . at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) . at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) . … 19 common frames omitted . Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘CCCOperatorClient’: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalStateException: PathVariable annotation was empty on param 0. at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:178) . at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:101) . at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1674) . at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getObjectForBeanInstance(AbstractAutowireCapableBeanFactory.java:1249) . at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:257) . at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) . at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1474) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1431) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1214) . at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1171) . at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) . at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) . … 33 common frames omitted . Caused by: java.lang.IllegalStateException: PathVariable annotation was empty on param 0. at feign.Util.checkState(Util.java:130) . at org.springframework.cloud.openfeign.annotation.PathVariableParameterProcessor.processArgument(PathVariableParameterProcessor.java:52) . at org.springframework.cloud.openfeign.support.SpringMvcContract.processAnnotationsOnParameter(SpringMvcContract.java:292) . at feign.Contract$BaseContract.parseAndValidateMetadata(Contract.java:110) . at org.springframework.cloud.openfeign.support.SpringMvcContract.parseAndValidateMetadata(SpringMvcContract.java:188) . at feign.Contract$BaseContract.parseAndValidatateMetadata(Contract.java:66) . at feign.hystrix.HystrixDelegatingContract.parseAndValidatateMetadata(HystrixDelegatingContract.java:47) . at feign.ReflectiveFeign$ParseHandlersByName.apply(ReflectiveFeign.java:154) . at feign.ReflectiveFeign.newInstance(ReflectiveFeign.java:52) . at feign.Feign$Builder.target(Feign.java:251) . at org.springframework.cloud.openfeign.HystrixTargeter.target(HystrixTargeter.java:55) . at org.springframework.cloud.openfeign.FeignClientFactoryBean.loadBalance(FeignClientFactoryBean.java:238) . at org.springframework.cloud.openfeign.FeignClientFactoryBean.getTarget(FeignClientFactoryBean.java:267) . at org.springframework.cloud.openfeign.FeignClientFactoryBean.getObject(FeignClientFactoryBean.java:247) . at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:171) . … 45 common frames omitted . ",
    "url": "http://localhost:4000/docs/errors/spring2/",
    "relUrl": "/docs/errors/spring2/"
  },"140": {
    "doc": "How to use Feign @SpringQueryMap",
    "title": "feign을 통해 @SpringQueryMap 사용",
    "content": ". ::요구사항 . 고객의 과거 상담 이력을 조회해서 다른 서비스로 전달하는 로직 . :: History API . @RestController @RequestMapping(\"histories\") public class HistoryQueryResource { private final HistoryQueryService historyQueryService; @GetMapping public HistoryList findAll( @SpringQueryMap HistoryQuery historyQuery ) { return historyQueryService.findAll(historyQuery); } } . ::Thirdparty . @FeignClient( contextId = \"HistoryQueryClient\", name = \"api\", configuration = {FeignConfiguration.class, FeignLoggerLevelConfiguration.class}, primary = false ) public interface HistoryQueryClient{ @GetMapping(\"histories\") HistoryList findAll(@SpringQueryMap HistoryQuery historyQuery); } . :: 문제 . | 컨트롤러가 Mapping파라미터로 선언한 HistoryQuery에 ArrayList, Map타입이 아니면 맵핑이 되지 않는 오류발생 | . @Builder @NoArgsConstructor(access = AccessLevel.PRIVATE) @AllArgsConstructor @Getter @ToString public class HistoryQuery implements JsonSerializable { @Builder.Default private int offset = 0; // --&gt; API서버로 맵핑되지 않음 @Builder.Default private int limit = 1; // --&gt; API서버로 맵핑되지 않음 @Builder.Default private IdList channelIds = IdList.empty(); // --&gt; 맵핑ok @Builder.Default private IdList status = IdList.empty(); // --&gt; 맵핑ok @Builder.Default private String customerId = StringUtils.EMPTY; // --&gt; API서버로 맵핑되지 않음 } . :: 문제 . | 호출 URL에는 문제가 없지만, History API 서버에는 offset, limit, customerId가 찍히지 않음 . -&gt; GET http://api/histories?offset=0&amp;status=closed&amp;limit=1 &amp;customerId=tester&amp;channelIds=kakao . | feign doc . | . Spring Cloud OpenFeign . doc을 보면, POJO, Map 모두 지원한다고 되어있지만, 테스트해보니 리스트나 맵이 아니면 안됨 . :: 문제해결 . | Param.Expander를 사용하는 방법 —&gt; 받는 쪽이 array, map이 아니면 이것도 안됨 | . Feign Client does not resolve Query parameter . | API 스펙을 변경하는 방법…. | . ",
    "url": "http://localhost:4000/docs/msa/feign/springQueryMap/#feign%EC%9D%84-%ED%86%B5%ED%95%B4-springquerymap-%EC%82%AC%EC%9A%A9",
    "relUrl": "/docs/msa/feign/springQueryMap/#feign을-통해-springquerymap-사용"
  },"141": {
    "doc": "How to use Feign @SpringQueryMap",
    "title": "How to use Feign @SpringQueryMap",
    "content": " ",
    "url": "http://localhost:4000/docs/msa/feign/springQueryMap/",
    "relUrl": "/docs/msa/feign/springQueryMap/"
  },"142": {
    "doc": "ssl 셋팅 후 갖가지 에러",
    "title": "ssl 셋팅 후 갖가지 에러",
    "content": ". | XMLHttpRequest cannot load https://aaa.ma.com:7443/. Response | . to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ . header is present on the requested resource. Origin . ‘http://127.0.0.1:8080’ is therefore not allowed access. | . | 접근한 aaa.ma.com 주소는 헤더가 다른 http://127.0.0.1:8080을 ajax로 호출할 수 없다. cors 때문에 | . | . | 공인인증서라면 인증서 설치에 문제겠지만 사설인증서인라면 인터넷브라우저의 인증서관리 화면에서 신뢰할수 잇는 루트기관으로 등록해준다 | . | . | 사설 인증서 브라우저에서 저장하려면 | . | . (1) 인터넷옵션 &gt; 내용 &gt; 인증서 선택 . (2) 신뢰할 수 있는 루트인증기관 탭 선택 &gt; 가져오기 . (3) 루트CA의 crt파일을 선택한다. (4) 브라우저 재시작 . | 제우스에 ssl셋팅하고 재시작했는데..아래처럼 truststore가 없다고 나오면..키파일 위치를 잘못잡았거나, 키스토어가 이상하거나 ㅠㅜ | . jeus.servlet.deployment.StartingException: File Not Found: D:\\TmaxSoft\\jeus6\\config\\testdomain\\truststore . | ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY | . | 크롬 버전 : 45.0.2454.99에서 나오는 에러로 ssl셋팅했을 때 보안설정이 낮아서 그런것으로.. | 크롬으로 url쳐서 개발자모드 보면 콘솔에 아래처럼 찍히는데.. 먼가 이제까지 브라우저에서 커버된게 deprecated된건가.. 모르겠지만 | . /deep/ combinator is deprecated. See https://www.chromestatus.com/features/6750456638341120 for more details. | 해결은 ssl인증서거는 설정에 ciper설정을 추가하면 된다. | 만약 톰캣이라면 아래처럼 connector설정 | . | err_ssl_fallback_beyond_minimum_version | . | 이것도 크롬에서만 나타난다 | 블로그) http://ondemand.tistory.com/214 | . 1) 크롬은 여전히 v45 에서 TLS v1.0 을 지원하고 있으니 TLS 버전 이슈는 아님, 2) 다만 크롬이 접속하려는 서버가 TLS Handshake 하는 과정에 이슈가 있을 경우, 기존에는 크롬이 Workaround 해주었지만, 3) v45 부터는 더이상 해당 Workaround 를 지원하지 않아서 발생하는 문제다 정도입니다. 구체적으로 어떤 웹 서버의 특정 버전이 이슈가 있는 것인지는 명확하게 정리된 내용을 찾지 못했습니다만 조치를 위해서는 서버측의 TLS Handshake 에 대한 보완이 필요한 것으로 추정 . ",
    "url": "http://localhost:4000/docs/errors/ssl1/",
    "relUrl": "/docs/errors/ssl1/"
  },"143": {
    "doc": "Sub Projects",
    "title": "Sub Projects",
    "content": "Projects that I work on personally. ",
    "url": "http://localhost:4000/docs/sub-projects",
    "relUrl": "/docs/sub-projects"
  },"144": {
    "doc": "점층적 생성자 패턴",
    "title": "점층적 생성자 패턴",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns/telescoping_constructor_pattern/",
    "relUrl": "/docs/patterns/telescoping_constructor_pattern/"
  },"145": {
    "doc": "Tesseract Ocr Study",
    "title": "tesseract ocr 공부",
    "content": "기술조사 ) Tesseract-ocr을 사용 . 순서1) 라이브러리설치에 앞서서, 맥으로 해야하기 때문에 홈브루 설치(https://whitepaek.tistory.com/3) . 순서2) tesseract, tesseract-lang설치 . brew install tesseract . brew install tesseract-lang . 순서3) sudo pip3 install pytesseract . sudo pip3 intall Image . 순서4) 실행한다. peter:~ peter$ tesseract /Users/peter/Downloads/IMG_5814.JPG /Users/peter/Downloads/aaa.txt -l kor . 순서4-1) 또는 파이썬으로 실행한다. import pytessearct . import PIL import Image . print(pytesseract.image_to_string(Image.open('/Users/peter/Downloads/IMG_5814.JPG'), lang='kor')) . 결과1) 별로 좋지 않은 결과 . 이 도 아이티 들으 그도 밸아차 가 소경더 [준공 023 자구 가바바 다자이 이누 그두자구 1611 11\\ 1000 너(|'0&gt;030)40) 이 지 성 지음 . 시도2) 이미지를 rotate시켜본다. &gt;&gt;&gt; im = Image.open('/Users/peter/Downloads/IMG_5814.JPG') &gt;&gt;&gt; img3 = im.rotate(90) &gt;&gt;&gt; print(pytesseract.image_to_string(img3, lang='kor')) . 결과2) 더 안좋음 ㅠㅜ . 몽|? 을 |? |0 도스 사기브 사고 ~ 요일 -………애 : 다 00000 0 디넌낸트이나 조는 [1 ~ 야 오어 1오 \" 0 . 시도3) tesseract의 train된 lang을 추가해본다. https://github.com/tesseract-ocr/tessdata/blob/master/kor.traineddata 에서 다운로드받고, . 받은 데이터파일을 아래에 추가. mac으로 terracert 를 설치한 경우, 추가할 위치는 /usr/local/share/tessdata 이다. 결과3) 첫번째에 비해 달라진걸 모르겠다 ㅠㅜ . 人 還 計生 lane Austen ()%+()&amp;1) 點 『 | 1 도 ~) 人 全 一 人 生 人 加 人 크 ” &gt; 재한 0 블 세 랐 도 기 ||” :( 총 니 . 내 - 올 를 SKIN 7! 올블 이 入 성 지음 . 시도4) 문제를 알았다… 폰트같은 글자 모양이나 길이에 대한 학습이 필요하다는 것을… . 시도5) 이미지를 box파일을 만든담에 https://hello-gg.tistory.com/5 에서처럼 하나씩 불러서 인식을 잡아준다. 그리고 학습 후 기존 학습파일에 add해준다. https://diyworld.tistory.com/114 . ",
    "url": "http://localhost:4000/docs/sub-projects/tesseract_ocr_study/#tesseract-ocr-%EA%B3%B5%EB%B6%80",
    "relUrl": "/docs/sub-projects/tesseract_ocr_study/#tesseract-ocr-공부"
  },"146": {
    "doc": "Tesseract Ocr Study",
    "title": "Tesseract Ocr Study",
    "content": " ",
    "url": "http://localhost:4000/docs/sub-projects/tesseract_ocr_study/",
    "relUrl": "/docs/sub-projects/tesseract_ocr_study/"
  },"147": {
    "doc": "Tolerant reader pattern",
    "title": "tolerant reader pattern",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns/tolerant_reader_pattern/#tolerant-reader-pattern",
    "relUrl": "/docs/patterns/tolerant_reader_pattern/#tolerant-reader-pattern"
  },"148": {
    "doc": "Tolerant reader pattern",
    "title": "Tolerant reader pattern",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns/tolerant_reader_pattern/",
    "relUrl": "/docs/patterns/tolerant_reader_pattern/"
  },"149": {
    "doc": "Type safe heterogeneous container pattern",
    "title": "타입 안전 이종 컨테이너 패턴",
    "content": "type safe heterogeneous container pattern . public class Favorites { public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance); public &lt;T&gt; T getFavorite(Class&lt;T&gt; type); } public static void main(String[] args) { Favorites f = new Favorites(); f.putFavorite(String.class, \"Java\"); f.putFavorite(Integer.class, 0xcafebabe); String favoritesString = f.getFavorite(String.class); } . | Favorites인스턴스는 String이 요청되면 Integer를 반환하는 일이 없기 때문에 타입안전하다고 볼 수 있다. | 일반 적인 맵과 달리 여러가지 타입의 원소를 담을 수 있어서, 타입안전이종 컨테이너라고 한다. | ex) DatabaseRow타입의 Column | . public class Favorites { private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorites(Class&lt;T&gt; type, T instance) { favorites.put(Objects.requireNonNull(type), type.cass(instance)); } } . | 타입을 한정시키고 싶다면? . | ex) annotation api | . public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType); static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName) { Class&lt;?&gt; annotationType = null; // 비한정적 타입 토큰 try { annotationType = Class.forName(annotationTypeName); } catch (Exception ex) { throw new IllegalArgumentException(ex); } return element.getAnnotation(annotationType.asSubclass(Annotation.class)); } . | annotationType인수는 한정적 타입 토큰 | . | . ",
    "url": "http://localhost:4000/docs/patterns/typesafe_heterogeneous_container_pattern/#%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%84-%EC%9D%B4%EC%A2%85-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%8C%A8%ED%84%B4",
    "relUrl": "/docs/patterns/typesafe_heterogeneous_container_pattern/#타입-안전-이종-컨테이너-패턴"
  },"150": {
    "doc": "Type safe heterogeneous container pattern",
    "title": "Type safe heterogeneous container pattern",
    "content": " ",
    "url": "http://localhost:4000/docs/patterns/typesafe_heterogeneous_container_pattern/",
    "relUrl": "/docs/patterns/typesafe_heterogeneous_container_pattern/"
  },"151": {
    "doc": "Udacity",
    "title": "Udacity",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udacity/udacity/",
    "relUrl": "/docs/mooc/udacity/udacity/"
  },"152": {
    "doc": "Udemy",
    "title": "Udemy",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udemy/udemy/",
    "relUrl": "/docs/mooc/udemy/udemy/"
  },"153": {
    "doc": "jetbrains.vcs.server.api.VcsServiceException Failed to construct commits graph for...",
    "title": "upsource 동기화 오류",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/upsource1/#upsource-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%98%A4%EB%A5%98",
    "relUrl": "/docs/errors/upsource1/#upsource-동기화-오류"
  },"154": {
    "doc": "jetbrains.vcs.server.api.VcsServiceException Failed to construct commits graph for...",
    "title": "problem",
    "content": "건물 정전되었을 때, upsource도 같이 고장나버렸다. 정전되면서 정리되지 못한 commit log파일들도 지우고, 어찌어찌 다시 살려냈는데 . hub의 프로젝트 목록에 들어가보면 이렇게 오류가 나있고 정전 이후에 커밋된 데이터를 가져오지 못했다. [error log] . Caused by: jetbrains.vcs.server.api.VcsServiceException: Failed to construct commits graph for talk-ui-backoffice{mappings: 1, mounts: 0}. Failed to const ruct graph for talk-ui-backoffice:. Failed to collect commits graph for talk-ui-backoffice:. jetbrains.buildServer.vcs.VcsException [2022-03-24 15:16:37,356] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphFactory.fetchGraph(CompositeGraphFactory.java:103) [2022-03-24 15:16:37,356] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.GraphServiceImpl.fetchGraph(GraphServiceImpl.java:68) [2022-03-24 15:16:37,356] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.FetchServiceImpl.fetch(FetchServiceImpl.java:22) [2022-03-24 15:16:37,356] [Upsource Frontend Error] at com.jetbrains.upsource.backend.cli.vcs.service.VcsServiceClient.processNewRevisions(VcsServiceClient.java:72) [2022-03-24 15:16:37,357] [Upsource Frontend Error] ... 19 more [2022-03-24 15:16:37,357] [Upsource Frontend Error] Caused by: jetbrains.vcs.server.api.VcsServiceException: Failed to construct graph for talk-ui-backoffice:. Failed to collect commits graph for talk-ui-ba ckoffice:. jetbrains.buildServer.vcs.VcsException [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.MappingCommitsGraphFutures$2.graph(MappingCommitsGraphFutures.java:41) [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphBuilder.includeMappings(CompositeGraphBuilder.java:128) [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphBuilder.loadGraphs(CompositeGraphBuilder.java:96) [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphBuilder.fetchAllGraphs(CompositeGraphBuilder.java:62) [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphFactory.fetchGraph(CompositeGraphFactory.java:99) [2022-03-24 15:16:37,357] [Upsource Frontend Error] ... 22 more [2022-03-24 15:16:37,357] [Upsource Frontend Error] Caused by: jetbrains.vcs.server.api.VcsServiceException: Failed to construct graph for talk-ui-backoffice:. Failed to collect commits graph for talk-ui-ba ckoffice:. jetbrains.buildServer.vcs.VcsException [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.MappingCommitsGraphFutures.error(MappingCommitsGraphFutures.java:57) [2022-03-24 15:16:37,357] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.MappingCommitsGraphFutures.errorGraph(MappingCommitsGraphFutures.java:31) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphBuilder.lambda$loadGraphs$0(CompositeGraphBuilder.java:117) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.threading.TrueParallelExecutionImpl$2.call(TrueParallelExecutionImpl.java:86) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at __. project_talk-ui-backoffice .__.call(JavaGeneratorTemplate.java:39) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at com.jetbrains.upsource.common.NamedFrameUtil.withProject(NamedFrameUtil.java:27) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at com.jetbrains.upsource.backend.cli.vcs.service.VcsServiceConnections$2.lambda$wrapMappingTask$0(VcsServiceConnections.java:73) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at java.util.concurrent.FutureTask.run(FutureTask.java:266) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.threading.TrueParallelExecutionImpl$1$1.run(TrueParallelExecutionImpl.java:51) [2022-03-24 15:16:37,358] [Upsource Frontend Error] ... 1 more [2022-03-24 15:16:37,358] [Upsource Frontend Error] Caused by: jetbrains.vcs.server.api.VcsServiceException: Failed to collect commits graph for talk-ui-backoffice:. jetbrains.buildServer.vcs.VcsException [2022-03-24 15:16:37,358] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.worker.VcsGraphSource.fetchCommits(VcsGraphSource.java:37) [2022-03-24 15:16:37,358] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.mapping.MappingCommitsGraphFactory.buildGraph(MappingCommitsGraphFactory.java:70) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.incremental.CachingCommitGraphFactory.buildGraph(CachingCommitGraphFactory.java:55) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphFactory$1.buildGraph(CompositeGraphFactory.java:85) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphBuilder.lambda$loadGraphs$0(CompositeGraphBuilder.java:110) [2022-03-24 15:16:37,359] [Upsource Frontend Error] ... 9 more [2022-03-24 15:16:37,359] [Upsource Frontend Error] Caused by: jetbrains.buildServer.vcs.VcsException: jetbrains.buildServer.vcs.VcsException [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.commitInfo.GitCommitsInfoBuilder.lambda$collectCommits$0(GitCommitsInfoBuilder.java:66) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.RepositoryManagerImpl.runWithDisabledRemove(RepositoryManagerImpl.java:268) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.commitInfo.GitCommitsInfoBuilder.collectCommits(GitCommitsInfoBuilder.java:59) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.vcs.api.services.collectChanges.CommitsInfoServiceProvider$1.collectCommits(CommitsInfoServiceProvider.java:33) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.worker.VcsGraphSource.fetchCommits(VcsGraphSource.java:33) [2022-03-24 15:16:37,359] [Upsource Frontend Error] ... 13 more [2022-03-24 15:16:37,359] [Upsource Frontend Error] Caused by: jetbrains.buildServer.vcs.VcsException [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.GitCollectChangesPolicy.fetchAllRefs(GitCollectChangesPolicy.java:143) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.GitFetchService.fetchRepositoryImpl(GitFetchService.java:59) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.GitFetchService.getOrCreateRepositoryState(GitFetchService.java:72) [2022-03-24 15:16:37,359] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.commitInfo.GitCommitsInfoBuilder.lambda$collectCommits$0(GitCommitsInfoBuilder.java:62) [2022-03-24 15:16:37,359] [Upsource Frontend Error] ... 17 more [2022-03-24 15:16:37,360] [Upsource Frontend Error] Caused by: java.lang.NegativeArraySizeException [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.PackIndexV1.&lt;init&gt;(PackIndexV1.java:96) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.PackIndex$PackIndexFactory.read(PackIndex.java:436) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.PackIndex$PackIndexFactory.open(PackIndex.java:391) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.PackFile.idx(PackFile.java:170) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.PackFile.get(PackFile.java:258) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.ObjectDirectory.openPackedObject(ObjectDirectory.java:417) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.ObjectDirectory.openPackedFromSelfOrAlternate(ObjectDirectory.java:386) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.ObjectDirectory.openObject(ObjectDirectory.java:378) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.internal.storage.file.WindowCursor.open(WindowCursor.java:145) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.lib.ObjectReader.open(ObjectReader.java:229) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.revwalk.RevWalk.parseAny(RevWalk.java:840) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.transport.FetchProcess.askForIsComplete(FetchProcess.java:344) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.transport.FetchProcess.executeImp(FetchProcess.java:159) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.transport.FetchProcess.execute(FetchProcess.java:122) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at org.eclipse.jgit.transport.Transport.fetch(Transport.java:1138) [2022-03-24 15:16:37,360] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.GitServerUtil.fetch(GitServerUtil.java:522) [2022-03-24 15:16:37,361] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.FetchCommandImpl.fetchInSameProcess(FetchCommandImpl.java:290) [2022-03-24 15:16:37,361] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.FetchCommandImpl.fetch(FetchCommandImpl.java:88) [2022-03-24 15:16:37,361] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.CommitLoaderImpl.fetch(CommitLoaderImpl.java:108) [2022-03-24 15:16:37,361] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.GitCollectChangesPolicy$FetchAllRefs.fetchTrackedRefs(GitCollectChangesPolicy.java:268) [2022-03-24 15:16:37,361] [Upsource Frontend Error] at jetbrains.buildServer.buildTriggers.vcs.git.GitCollectChangesPolicy.fetchAllRefs(GitCollectChangesPolicy.java:140) [2022-03-24 15:16:37,361] [Upsource Frontend Error] ... 20 more ... 38 more [2022-03-24 15:20:37,732] [Upsource Frontend Error] [2022-03-24 15:20:37,727] WARN VcsService-7 k-ui-backoffice h.global.CompositeGraphBuilder - Failed to construct mounted graph for talk-ui-backoffice:. Failed to collect commits graph for talk-ui-backoffice:. jetbrains.buildServer.vcs.VcsException [2022-03-24 15:20:37,732] [Upsource Frontend Error] jetbrains.vcs.server.api.VcsServiceException: Failed to collect commits graph for talk-ui-backoffice:. jetbrains.buildServer.vcs.VcsException [2022-03-24 15:20:37,732] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.worker.VcsGraphSource.fetchCommits(VcsGraphSource.java:37) [2022-03-24 15:20:37,732] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.mapping.MappingCommitsGraphFactory.buildGraph(MappingCommitsGraphFactory.java:70) [2022-03-24 15:20:37,732] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.incremental.CachingCommitGraphFactory.buildGraph(CachingCommitGraphFactory.java:55) [2022-03-24 15:20:37,732] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphFactory$1.buildGraph(CompositeGraphFactory.java:85) [2022-03-24 15:20:37,732] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.graph.global.CompositeGraphBuilder.lambda$loadGraphs$0(CompositeGraphBuilder.java:110) [2022-03-24 15:20:37,733] [Upsource Frontend Error] at jetbrains.vcs.server.core.impl.threading.TrueParallelExecutionImpl$2.call(TrueParallelExecutionImpl.java:86) [2022-03-24 15:20:37,733] [Upsource Frontend Error] at __. project_talk-ui-backoffice .__.call(JavaGeneratorTemplate.java:39) [2022-03-24 15:20:37,733] [Upsource Frontend Error] at com.jetbrains.upsource.common.NamedFrameUtil.withProject(NamedFrameUtil.java:27) [2022-03-24 15:20:37,733] [Upsource Frontend Error] at com.jetbrains.upsource.backend.cli.vcs.service.VcsServiceConnection . ",
    "url": "http://localhost:4000/docs/errors/upsource1/#problem",
    "relUrl": "/docs/errors/upsource1/#problem"
  },"155": {
    "doc": "jetbrains.vcs.server.api.VcsServiceException Failed to construct commits graph for...",
    "title": "solution",
    "content": "원인은 temp하위의 일부 파일이 서비스를 올린 계정과 달라서 접근할 수 없어서 동기화가 안되었던것 . /home/upsource/upsource-2020.1.1802/temp/upsource-frontend/vcs-service/caches/plugins/git . | ./upsource.sh stop | . 그래서 서비스 내리고 . | rm -rf * /home/upsource/upsource-2020.1.1802/temp | . temp폴더에 있는 파일들 모두 삭제하고 . | ./upsource.sh start | . 다시 재기동하니 solved~ . ",
    "url": "http://localhost:4000/docs/errors/upsource1/#solution",
    "relUrl": "/docs/errors/upsource1/#solution"
  },"156": {
    "doc": "jetbrains.vcs.server.api.VcsServiceException Failed to construct commits graph for...",
    "title": "jetbrains.vcs.server.api.VcsServiceException Failed to construct commits graph for...",
    "content": " ",
    "url": "http://localhost:4000/docs/errors/upsource1/",
    "relUrl": "/docs/errors/upsource1/"
  },"157": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "[Udemy] vuejs-2-the-complete-guide 후기",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#udemy-vuejs-2-the-complete-guide-%ED%9B%84%EA%B8%B0",
    "relUrl": "/docs/mooc/udemy/vuejs/#udemy-vuejs-2-the-complete-guide-후기"
  },"158": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "강의 URL",
    "content": "https://www.udemy.com/course/vuejs-2-the-complete-guide/ . ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%EA%B0%95%EC%9D%98-url",
    "relUrl": "/docs/mooc/udemy/vuejs/#강의-url"
  },"159": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "학습 툴",
    "content": ". | visual studio code | . ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%ED%95%99%EC%8A%B5-%ED%88%B4",
    "relUrl": "/docs/mooc/udemy/vuejs/#학습-툴"
  },"160": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "강의 구성",
    "content": ". | 총 670강의로 49시간 정도 소요. | vuejs버전이 올라갔을 때 강의가 업데이트 된다. | 강의 하나당 최소 1분에서 최대 15분 안팍으로 짧게 나눠져 있어서 수강하기 수월 | 강좌마다 기본 프로젝트가 첨부되어 있고, 강의 내용 들으면서 해당 프로젝트에 코딩을 하면 된다. | 과제 : 건너뛰기가 가능하지만, 과제를 통해서 복습이 가능. | . 세션 1 ~ 세션 5 : Vuejs의 기본 . 세션 6 ~ 세션 9 : 컴포넌트 학습 . 세션 10 : 이제까지 배운 것으로 미니프로젝트 구성학습 . 세션 11 : 폼 학습 . 세션 12 : Http Request호출 . 세션 13 : 라우팅 학습 . 세션 14 : Animations &amp; Transitions . 세션 15 : Vuex 학습 . 세션 16 : Web app 프로젝트 구성 학습 . 세션 17 ~ 세션 44 : 기타 프로젝트에 필요한 학습 . ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%EA%B0%95%EC%9D%98-%EA%B5%AC%EC%84%B1",
    "relUrl": "/docs/mooc/udemy/vuejs/#강의-구성"
  },"161": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "선수 학습 조건",
    "content": ". | 기본 javascript 지식 필요 | ES6도 알아야하지만 필수는 아님. —&gt; 학습에 지장없음. | 기본 Html 및 CSS에 대해서 설명하지 않기때문에, 기본적인 것은 알고 있어야 한다. | . ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%EC%84%A0%EC%88%98-%ED%95%99%EC%8A%B5-%EC%A1%B0%EA%B1%B4",
    "relUrl": "/docs/mooc/udemy/vuejs/#선수-학습-조건"
  },"162": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "언어 지원",
    "content": "영어로 진행되는 수업으로 한글 자막은 없고 영어 및 유럽권 자막이 있다. 강사님 말투가 빠른 편이 아니여서, 충분히 이해하고 따라가기에 어렵지 않음. ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%EC%96%B8%EC%96%B4-%EC%A7%80%EC%9B%90",
    "relUrl": "/docs/mooc/udemy/vuejs/#언어-지원"
  },"163": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "학습 후기",
    "content": ". | 평일에는 1~2강의 정도 수강하고 있어서, 아직 세션10 ㅎ | 기초부터 실전까지 활용가능한 내용으로 잘 구성되어있는 것 같다. | 강의 속도도 빠르지 않고, Vuejs를 처음 접한 사람에게는 좋은 강의!! | 강의를 다 듣고 프로젝트에 바로 투입도 가능해보인다! | . ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%ED%95%99%EC%8A%B5-%ED%9B%84%EA%B8%B0",
    "relUrl": "/docs/mooc/udemy/vuejs/#학습-후기"
  },"164": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "학습 요약",
    "content": "1.75x 정주행 요약 . ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/#%ED%95%99%EC%8A%B5-%EC%9A%94%EC%95%BD",
    "relUrl": "/docs/mooc/udemy/vuejs/#학습-요약"
  },"165": {
    "doc": "vuejs-2-the-complete-guide 후기",
    "title": "vuejs-2-the-complete-guide 후기",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs/",
    "relUrl": "/docs/mooc/udemy/vuejs/"
  },"166": {
    "doc": "1.75x 정주행 요약",
    "title": "1.75x 정주행 요약",
    "content": " ",
    "url": "http://localhost:4000/docs/mooc/udemy/vuejs_sub/",
    "relUrl": "/docs/mooc/udemy/vuejs_sub/"
  },"167": {
    "doc": "웹API 디자인",
    "title": "웹API 디자인",
    "content": ". | 사용자를 위한 API 디자인하기 2.3.5 API 목표 캔버스 . | 누가 - API를 사용하는 사용자들을 나열 | 무엇을 - API로 사용자들이 할 수 있는 것을 나열 | 어떻게 - 무엇을 단계별로 분해해 나열 | 입력(원천) - 각 단계를 진행하기 위해 필요한 요소들과 그것들의 원천을 나열(누락된 누가, 무엇을 또는 어떻게를 찾기 위함) | 출력(사용처) - 각 단계의 반환과 그 쓰임새를 나열(누락된 누가, 무엇 또는 어떻게를 찾기 위함) | 목표 - 명시적이고 간결하게 각각의 어떻게 + 입력 + 출력을 재구성 | . | . ",
    "url": "http://localhost:4000/docs/clipping/java/webapi/",
    "relUrl": "/docs/clipping/java/webapi/"
  }
}
